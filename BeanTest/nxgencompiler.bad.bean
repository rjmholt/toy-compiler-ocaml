# This version of the file has some static compilation errors
typedef {fA : int, fB : {gA : bool, gB : bool}} a_record
typedef {used : bool, rec : a_record} b_record
typedef {fA : int, fB : bool} c_record
typedef {fB : bool, fA : int} d_record
typedef {fA : bool, fB : int} e_record
typedef {gA : c_record, gB : d_record} f_record
typedef {gA : {fA : int, fB : bool}, gB : {fA : int, fB : bool}} g_record

proc equiv()
    # Tests for equivalence of types
    int x;
    int y;
    bool z;
    bool w;
    c_record cr;
    d_record dr;
    e_record er;
    f_record fr;
    g_record gr;

    x := 2;
    y := 2;
    if x = y then
        write "correct";
    else
        write "incorrect";
    fi
    cr := {fA = x, fB = z};
    cr := dr;   # dr should be automatically initialised to {fB = false, fA = 0}
    cr := er;   # Type error
    if fr.gA != dr then
        write "Compound type initialised incorrectly";
    fi
    fr := {gA = cr, gB = cr};
    gr.gA.fB := true;
    gr.gB := cr;
    write gr;
    fr := {gA = {fA = 2, fB = gr.gA.fB}};   # Note: missing gB argument is legal
    gr := fr;   # Same type signature defined in two different ways, should pass
    z := true;
    w := false;
    if z and w or (z and not w and 3 < 7) then
        write "yay";
    else
        write "nay!";
    fi
end

proc q(val bool x, ref b_record k)
    int n;          # Note: Unused variable
    bool y;
    a_record z;
    b_record x;     # error; x already exists in this scope; val bool x

    y := y + 2;     # Should not compile - type error
    x := k;
    z.fA := 42;
    z.fB := {gB = true, gA = false};
    x.rec := z;
    x.rec.fB.gA := x.used;

    y := false < true;  # Type error in comparison - Should not compile
    y := false >= true; # Type error in comparison - Should not compile
    y := false != true;
    if y != true then
        write "boolean comparison fail!";
    else
        write "yay";
    fi
end

proc p(ref int i)
    int j;
    int k;
    int l;

    i := 6 * i + 4;
    j := -5 + 2;
    k := - 5 + 2;
    l := -5 + 2;
    l := (13 + 27) / (4 * 3 + 2 - 23) / 7;          # Integer division => 0
    read h;         # This is not defined, should error during compilation.
end

proc main()
    int m;
    int n;

    read n;
    while n > 1 do
        m := n;
        while m > 0 do
            if m > 0 then
                n := n - 1;
                m := m - 1;
                if m = 0 then
                    p(n);
                fi
            else
                m := n - m;
                m := m - 1;
            fi
        od
    od
    equiv();
end
