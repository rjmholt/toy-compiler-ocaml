# Some typedefs
typedef bool myBool
typedef {
    a: int,
    b: {x: myBool, g: int}
} aType
typedef aType bType

# Tests the 'write' command with different strings
proc writeTest(val int x, ref bool y, val bType z)
    write "---- Begin write test ----\n";

    write "'Kevin!' she shouted politely\n";
    write "\ \' \nduck\rgoose\trabbit\\\bemu(^&)~|\n";
    write "\n \\n \\\n \\\\n \n";
    write x;
    write y;
    write z.b.x;
    write "\n";
end

# Tests boolean operators
proc boolTest(val bool x, val bool y)
    bool p;
    bool q;

    write "---- Begin bool test ----\n";

    p := not x = y;
    q := x and (p or y);

    if p then
        write "p is true\n";
    fi

    if q then
        write "q is true\n";
    fi
    write "\n";
end

# Tests division order
proc divTest()
    int x;
    int y;
    int z;
    int p;
    int q;

    write "---- Begin division test ----\n";

    x := 100; y:= 20; z := 5;

    if x / y / z = 1 then
        write "100 / 20 / 5 = 1\n";
    else
        write "100 / 20 / 5 != 1\n";
    fi

    if x / (y / z) = 25 then
        write "100 / (20 / 5) = 25\n";
    else
        write "100 / (20 / 5) != 25\n";
    fi 
    write "\n";
end

# Tests expression handling and reading
proc readExprTest()
    int x;
    int y;

    write "---- Begin read/expr test ----\n";

    write "Enter a value for x: ";
    read x;
    write "\n";

    write "Enter a value for y: ";
    read y;
    write "\n";

    write ((28 - 3 + y) * x / 4 * (x + x * y / y));
    write "\n";
end

# Tests overflow semantics
proc overflowTest()
    int x;
    int y;
    int z;

    write "---- Begin overflow test ----\n";

    x := 2147483637;
    y := 2147483635;
    z := 10;

    write z + (x - y);
    write z + x - y;
    write z / x * y;
    write z / (x * y);
    write "\n";
end

# Sets n to 91
proc ninetyone(ref int n)
    if n > 100 then
        n := n - 10;
    else
        n := n + 11;
        ninetyone(n);
        ninetyone(n);
    fi
end

# Checks if x is less than 1, otherwise calls mutual_two on x
proc mutual_one(val int x)
    if x <= 1 then
        write "Finished\n";
    else
        mutual_two(x);
    fi
end

# If x is even divide by two and call mutual_one on it
# If x is odd, multiply by three and add one and call mutual_one on it
proc mutual_two(val int x)
    write x;
    write "\n";

    if x - 2 * (x / 2) = 0 then
        mutual_one(x/2);
    else
        mutual_one(3*x # Hello
                   + 1);
    fi
end

proc main()
    int x;
    int n;
    bool y;
    bool p;
    bType z;

    y := true;
    z := { b = { x = true } };
    writeTest(0, y, z);

    boolTest(y, z.b.x);

    divTest();

    overflowTest();

    write "---- Testing default int value ----\n";
    write "n = "; write n; write "\n";
    write "\n";

    write "---- Testing default bool value ----\n";
    if p then
        write "Hello\n";
    else
        write "p's default is correctly 0\n";
    fi
    write "\n";

    write "---- Testing McCarthy91 ----\n";
    n := 36;
    write "n = "; write n; write "\n";
    ninetyone(n);
    write "n = "; write n; write "\n";
    write "\n";

    write "---- Testing mutually recursive collatz function ----\n";
    mutual_one(n);
    write "\n";
end
