============================================
vis/rholt.out
16:38:25_Friday_20_May_2016
============================================
COMP90045 project stage 3 - Test of the Bean compiler
User:  rholt

--- Makefile found ---
--- Running Makefile ---
ocamlc  -c bean_ast.mli
ocamlopt  -g -c bean_ast.ml
ocamlyacc -v bean_parse.mly
ocamlc  -c bean_parse.mli
ocamlopt  -g -c bean_parse.ml
ocamllex bean_lex.mll
100 states, 5825 transitions, table size 23900 bytes
ocamlopt  -g -c bean_lex.ml
ocamlc  -c bean_pprint.mli
ocamlopt  -g -c bean_pprint.ml
ocamlc  -c bean_symtbl.mli
ocamlopt  -g -c bean_symtbl.ml
ocamlc  -c bean_semantic.mli
ocamlopt  -g -c bean_semantic.ml
ocamlc  -c bean_intermediate_code.mli
ocamlopt  -g -c bean_intermediate_code.ml
ocamlc  -c bean_oz.mli
ocamlopt  -g -c bean_oz.ml
ocamlopt  -g -c bean.ml
ocamlopt -g -o bean bean_ast.cmx bean_lex.cmx bean_parse.cmx bean_pprint.cmx bean_symtbl.cmx bean_semantic.cmx bean_intermediate_code.cmx bean_oz.cmx bean.cmx

--- Succeeded ---


PLEASE NOTE: These cases are very basic and are not intended to be
comprehensive. Passing these does not guarantee a correct compiler!

--- Running basic test of each milestone ---
Milestone 1: Expressions and write statement
PASS
Milestone 2: Read and assignment statements
PASS
Milestone 3: If and while statements
PASS
Milestone 4: Procedure arguments and calls (by-value only)
PASS
Milestone 5: By-reference arguments
PASS
Milestone 6: Structures
COMPILE ERROR:
Fatal error: exception Bean_intermediate_code.Unsupported("No such field in the struct")
Milestone 7: Semantic errors
PASS:
Compiler output:
42 cannot be passed by reference: From line 10, column 7 to line 10, column 9 in file "../data/milestones/milestone7.bad.bean"

--- Running simple tests ---
vis/*.bean)
bell:               PASS
fib:                FAIL:
Expected output:
>34
Got:
>0
gcd:                PASS
hail:               FAIL:
Expected output:
1 2 8 3 6 9 17 4 20 7 15 10 10 18 18 5 13 21 21 8 
Got:
0 2 8 3 6 9 17 4 20 7 15 10 10 18 18 5 13 21 21 8 
power:              FAIL:
Expected output:
Integer x: Positive integer n: x^n is: 2187
Got:
Integer x: Positive integer n: x^n is: 0
tute_question_42:   PASS
tute_question_44:   PASS
4/7 cases passed
3 cases failed

--- Running peer-contributed tests ---
(made_avail/*.bean)
allgood:            PASS
antiOcaml:          PASS
beyondasciiart:     FAIL:
Expected output:
The factorial of 1 is 1
The factorial of 2 is 2
The factorial of 50 is 0
The factorial of 80 is 0
The factorial of 500 is 0
The factorial of 50000 is 0
Error
The factorial of -1 is -1
Got:
The factorial of 1 is 0
The factorial of 2 is 0
Error
The factorial of 50 is 0
Error
The factorial of 80 is 0
Error
The factorial of 500 is 0
Error
The factorial of 50000 is 0
Error
The factorial of -1 is 0
buffalo:            PASS
cocoa:              PASS
Cromwell:           PASS
emc:                COMPILE ERROR:
Type error in `player = true`: From line 46, column 8 to line 46, column 21 in file "../data/made_avail/emc.bean"
half:               PASS
HAX:                COMPILE ERROR:
Parse error at line 2, column 33 in file "../data/made_avail/HAX.bean"
HighSkill:          PASS
Kylin:              PASS
LamentingLexers:    COMPILE ERROR:
Parse error at line 6, column 11 in file "../data/made_avail/LamentingLexers.bean"
Legumes:            PASS
nxgencompiler.bad:  PASS:
Compiler output:
The variable x is already declared: From line 54, column 5 to line 54, column 16 in file "../data/made_avail/nxgencompiler.bad.bean"
nxgencompiler:      COMPILE ERROR:
Fatal error: exception Bean_symtbl.Undefined_field("gA", _)
OEucalyptBean:      PASS
pli:                COMPILE ERROR:
Parse error at line 2, column 12 in file "../data/made_avail/pli.bean"
ramen:              FAIL:
Fatal error:
Output:
This program will sort two given integers in ascending order
Please enter two integers: 

Error:
at instruction 38, pc 26: register 0 doesn't contain an int
at instruction 38, pc 26: register 1 doesn't contain an int
random:             PASS
togetherness:       PASS
13/20 cases passed
7 cases failed


--- End of testing for rholt ---

============================================
src/bean_parse.mly
16:38:20_Friday_20_May_2016
============================================
/* =========================================================== */
/* Ocamlyacc parser for the Bean Language                      */
/* ----------------------------------------------------------- */
/* Parser used by the Bean Lexer (bean_lex.mll) in order to    */
/* run semantic anaylses on the generated tokens. Opens        */
/* bean_ast.ml to convert parsed language to an abstract       */
/* syntax tree                                                 */
/* =========================================================== */
%{
  open Bean_ast

  let sym_pos () =
    let start = Parsing.symbol_start_pos () in
    let finish = Parsing.symbol_end_pos () in
    (start, finish)
%}

/* Literal tokens */
%token <bool>   BOOL_CONST
%token <int>    INT_CONST
%token <string> STR_CONST

/* Identifier token */
%token <string> IDENT

/* Other language tokens */
%token BOOL INT
%token WRITE READ
%token ASSIGN
%token IF THEN ELSE FI
%token WHILE DO OD
%token PROC END
%token TYPEDEF
%token DOT
%token VAL REF
%token COMMA
%token LPAREN RPAREN
%token LBRACE RBRACE
%token OR
%token AND
%token NOT
%token EQ NEQ LT LEQ GT GEQ
%token PLUS MINUS MUL DIV
%token COLON
%token SEMICOLON
%token EOF

/* Operator precedence in increasing order */
%left     OR
%left     AND 
%nonassoc UNOT
%nonassoc EQ NEQ LT LEQ GT GEQ
%left     PLUS MINUS
%left     MUL DIV
%nonassoc UMINUS

/* Final type of bean parse tree at top level */
%type <Bean_ast.program> program

%start program
%%

/* ---- Parser Grammar Rules ---- */

/* Start symbol for Bean program production */
program:
  typedefs procs { { typedefs = List.rev $1 ; procs = List.rev $2 } }

/* Type definition list rule */
typedefs:
  | typedefs typedef { $2 :: $1 }
  |                  { [] }

/* Single typedef rule */
typedef:
  TYPEDEF typespec IDENT { ($2, $3, sym_pos ()) }


/* Native bean type rules */
beantype:
  | BOOL { TBool }
  | INT  { TInt  }

/* User defined types -- equivalent to idents */
definedtype:
  IDENT { $1 }

/* Bean type specifiers */
typespec:
  | beantype             { TSBeantype    $1 }
  | definedtype          { TSDefinedtype ($1, sym_pos ()) }
  | LBRACE fields RBRACE { TSFieldStruct (List.rev $2) }

/* Fields of a struct-like type specifier */
fields:
  | fields COMMA field { $3 :: $1 }
  | field              { [$1] }

/* A single struct field */
field:
  IDENT COLON typespec { ($1, $3, sym_pos ()) }

/* Bean procedure list rule */
procs:
  | procs proc { $2 :: $1 }
  | proc       { [$1] }

/* Rule for producing a single procedure */
proc:
  | PROC IDENT LPAREN RPAREN proc_body END { ($2, [], $5, sym_pos ()) }
  | PROC IDENT LPAREN proc_params RPAREN proc_body END { ($2,
                                                         List.rev $4,
                                                         $6,
                                                         sym_pos ()) }

/* Parameter list in a procedure header (between the parentheses) */
proc_params:
  | proc_params COMMA proc_param { $3 :: $1 }
  | proc_param                   { [$1] }

/* Individual parameter */
proc_param:
  pass_type typespec IDENT { ($1, $2, $3, sym_pos ()) }

/* The way a parameter is passed to the procedure,
   either by value or by reference                 */
pass_type:
  | VAL { Pval }
  | REF { Pref }

/* The body of a proc, composed of declarations and statements */
proc_body:
  decls stmts { (List.rev $1, List.rev $2) }

/* A list of declarations in a bean procedure */
decls:
  | decls decl { $2 :: $1 }
  |            { [] }

/* A single declaration in the list of declarations */
decl:
  typespec IDENT SEMICOLON { ($2, $1, sym_pos ()) }

/* The list of statements in a bean procedure */
/* Builds stmts in non-reverse, right-recursive order */
/* This is to eliminate a parser conflict error, but ideally
   the grammar could be restructured to eliminate it         */
stmts:
  | stmts stmt { $2 :: $1 }
  | stmt       { [$1] }

/* A single statement is either a semi-colon terminated statement,
   or a conditional, being if, if-else or while                    */
stmt:
  | stmt_body SEMICOLON              { $1 }
  | IF expr THEN stmts FI            { If ($2, $4) }
  | IF expr THEN stmts ELSE stmts FI { IfElse ($2, $4, $6) }
  | WHILE expr DO stmts OD           { While ($2, $4) }

/* A statement that precedes a semicolon */
stmt_body:
  | proc_call            { ProcCall $1 }
  | READ lvalue          { Read     $2 }
  | WRITE writeable      { Write    $2 }
  | lvalue ASSIGN rvalue { Assign ($1, $3, sym_pos ()) }

/* A procedure call, that takes a named function and
   a list of expressions to pass in                   */
proc_call:
  IDENT LPAREN exprs RPAREN { ($1, List.rev $3, sym_pos ()) }

/* A list of expressions, being the expressions passed in to
   a bean procedure, separated by a comma                    */
exprs:
  | exprs COMMA expr { $3 :: $1 }
  | expr             { [$1] }
  |                  { [] }

/* An rvalue for assignment, can be a simple expression or
   a struct field initialiser                              */
rvalue:
  | expr        { Rexpr   $1 }
  | struct_init { Rstruct $1 }

/* A struct initialiser, like "{x = 1, y = true}", sets the
   fields of an lvalue that denotes a structured type       */
struct_init:
  LBRACE struct_assigns RBRACE { List.rev $2 }

/* The list of field assignments in a struct initialiser */
struct_assigns:
  | struct_assigns COMMA struct_assign  { $3 :: $1 }
  | struct_assign                       { [$1] }
  |                                     { [] }

/* A single field assignment in a struct initialiser */
struct_assign:
  IDENT EQ rvalue { ($1, $3, sym_pos ()) }

/* An lvalue is either a simple identifier for a simply typed
   identifier, or a field accessor like "x.y.z", which denotes
   a field of a higher lvalue                                  */
lvalue:
  | IDENT DOT lvalue { LField ($3, $1) }
  | IDENT            { LId ($1, sym_pos ()) }

/* A bean expression, being either a literal, an lvalue,
   a binary operator applied to two subexpressions, a unary operator
   applied to a subexpression, or an expression in parentheses
   to denote increased precedence of the expression within           */
expr:
  | literal            { $1 }
  | lvalue             { Elval ($1, sym_pos ()) }
  | binop              { $1 }
  | unop               { $1 }
  | LPAREN expr RPAREN { $2 }

/* A literal is either a boolean or integer literal,
   such as "true" or "8123"                          */
literal:
  | BOOL_CONST { Ebool ($1, sym_pos ()) }
  | INT_CONST  { Eint  ($1, sym_pos ()) }

/* A binary operation, applied to two subexpressions */
binop:
  | expr PLUS  expr { Ebinop ($1, Op_add, $3, sym_pos ()) }
  | expr MINUS expr { Ebinop ($1, Op_sub, $3, sym_pos ()) }
  | expr MUL   expr { Ebinop ($1, Op_mul, $3, sym_pos ()) }
  | expr DIV   expr { Ebinop ($1, Op_div, $3, sym_pos ()) }
  | expr AND   expr { Ebinop ($1, Op_and, $3, sym_pos ()) }
  | expr OR    expr { Ebinop ($1, Op_or,  $3, sym_pos ()) }
  | expr EQ    expr { Ebinop ($1, Op_eq,  $3, sym_pos ()) }
  | expr NEQ   expr { Ebinop ($1, Op_neq, $3, sym_pos ()) }
  | expr LT    expr { Ebinop ($1, Op_lt,  $3, sym_pos ()) }
  | expr LEQ   expr { Ebinop ($1, Op_leq, $3, sym_pos ()) }
  | expr GT    expr { Ebinop ($1, Op_gt,  $3, sym_pos ()) }
  | expr GEQ   expr { Ebinop ($1, Op_geq, $3, sym_pos ()) }

/* A unary operator, applied to a single subexpression */
unop:
  | MINUS expr %prec UMINUS { Eunop (Op_minus, $2, sym_pos ()) }
  | NOT   expr %prec UNOT   { Eunop (Op_not,   $2, sym_pos ()) }

/* Either a bean expression or a string literal */
writeable:
  | expr      { WExpr   $1 }
  | STR_CONST { WString $1 }
============================================
src/bean_intermediate_code.ml
16:38:20_Friday_20_May_2016
============================================
module AST = Bean_ast
module Sym = Bean_symtbl
module Sem = Bean_semantic
module P   = Bean_pprint

(* ========================================================================== *)
(* ======================= DATA STRUCTURE DEFINITIONS ======================= *)
(* ========================================================================== *)

type reg        = Reg       of int    (* A register                          *)
type stack_slot = StackSlot of int    (* Slot in the activation record stack *)
type label      = Label     of string (* An instruction block label          *)
type scope      = Val | Ref           (* Variable scope (value or reference) *)

(* Builtin oz functions *)
type builtin =
  | ReadInt
  | ReadBool
  | PrintInt
  | PrintBool
  | PrintString

(* Machine instructions *)
type instr =
  (* Stack manipulation *)
  | PushStackFrame of int
  | PopStackFrame  of int
  (* Register store/load *)
  | Load           of reg        * stack_slot
  | Store          of stack_slot * reg
  | LoadAddress    of reg        * stack_slot
  | LoadIndirect   of reg        * reg
  | StoreIndirect  of reg        * reg
  (* Register immediate operations *)
  | IntConst       of reg * int
  | StringConst    of reg * string
  (* Integer arithmetic operations *)
  | AddInt         of reg * reg * reg
  | SubInt         of reg * reg * reg
  | MulInt         of reg * reg * reg
  | DivInt         of reg * reg * reg
  (* Address offset operations *)
  | AddOffset      of reg * reg * reg
  | SubOffset      of reg * reg * reg
  (* Integer comparison operations *)
  | CmpEqInt       of reg * reg * reg
  | CmpNeqInt      of reg * reg * reg
  | CmpGtInt       of reg * reg * reg
  | CmpGeqInt      of reg * reg * reg
  | CmpLtInt       of reg * reg * reg
  | CmpLeqInt      of reg * reg * reg
  (* Boolean arithmetic operations *)
  | And            of reg * reg * reg
  | Or             of reg * reg * reg
  | Not            of reg * reg
  (* Move *)
  | Move           of reg * reg
  (* Branch instructions *)
  | BranchOnTrue   of reg * label
  | BranchOnFalse  of reg * label
  | BranchUncond   of label
  (* Calls *)
  | Call           of label
  | CallBuiltin    of builtin
  | Return
  (* Emulator halt *)
  | Halt
  (* A label pseudo-instruction *)
  | BlockLabel     of label
  (* Debug instructions *)
  | DebugReg       of reg
  | DebugSlot      of stack_slot
  | DebugStack

type code = instr list  (* code, by definition, is a list of instructions *)

(* Exceptions *)
exception Unsupported of string

(* ========================================================================== *)
(* ====================== BEAN CODE TO IR TRANSLATION ======================= *)
(* ========================================================================== *)

(* ============================= Declarations =========================== *)

(* Generate code for a single declaration of a primitively typed variable *
 * both ints and bools are treated as ints in oz                          *)
let gen_bt_decl_code frame_size bt =
    match bt with
    | AST.TInt  -> [Store (StackSlot frame_size, Reg 0); IntConst (Reg 0, 0)]
    | AST.TBool -> [Store (StackSlot frame_size, Reg 0); IntConst (Reg 0, 0)]

(* Generate code for declaration of a field in a struct, can be recursive *)
let rec gen_field_decl_code _id (type_sym, slot) (prev_slot, prev_code) =
  match type_sym with
  | Sym.STBeantype bt ->
      slot := Some prev_slot;
      let bt_code = gen_bt_decl_code prev_slot bt in
      (prev_slot+1, bt_code @ prev_code)
  | Sym.STFieldStruct fields ->
      Hashtbl.fold gen_field_decl_code fields (prev_slot, prev_code)

(* Generate code for a single declaration *)
let gen_decl_code symtbl proc_id (frame_size, code) (id, _, _) =
  let decl_type = Sym.get_id_type symtbl proc_id id in
  (* Store the location of this symbol in the symbol table *)
  let (new_frame, decl_code) =
    match decl_type with
    | Sym.STBeantype bt ->
        let new_slot = Sym.set_id_slot symtbl proc_id id frame_size in
        let bt_code  = gen_bt_decl_code frame_size bt in
        (new_slot, bt_code)
    | Sym.STFieldStruct fields ->
        Hashtbl.fold gen_field_decl_code fields (frame_size, [])
  in
  (new_frame, decl_code @ code)

(* =========================== Type Resolution  ============================= *)

let get_pass_type scope =
  match scope with
  | Sym.SDecl | Sym.SParamVal -> Val
  | Sym.SParamRef             -> Ref

(* Get the type of a unary operator *)
let get_unop_type unop =
  match unop with
  | AST.Op_minus -> Sym.STBeantype AST.TInt
  | AST.Op_not   -> Sym.STBeantype AST.TBool

(* Get the type of a binary operator *)
let get_binop_type binop =
  match binop with
  | AST.Op_add | AST.Op_sub
  | AST.Op_mul | AST.Op_div  -> Sym.STBeantype AST.TInt
  | AST.Op_and | AST.Op_or
  | AST.Op_eq  | AST.Op_neq
  | AST.Op_lt  | AST.Op_leq
  | AST.Op_gt  | AST.Op_geq  -> Sym.STBeantype AST.TBool

(* Get the type of an expression *)
let get_expr_type symtbl proc_id expr =
  match expr with
  | AST.Ebool  _                -> Sym.STBeantype AST.TBool
  | AST.Eint   _                -> Sym.STBeantype AST.TInt
  | AST.Elval  (lval, _)        -> Sym.get_lval_type symtbl proc_id lval
  | AST.Eunop  (unop, _, _)     -> get_unop_type unop
  | AST.Ebinop (_, binop, _, _) -> get_binop_type binop

(* ================================ IO Read ================================= *)

(* Generate code to read in a value, type sensitive *)
let gen_read_code symtbl proc_id lval =
  let pos = AST.get_lval_pos lval in
  let bt =
    match Sym.get_lval_type symtbl proc_id lval with
    | Sym.STBeantype beantype -> beantype
    | _                       ->
        raise (Sem.Read_struct (P.string_of_lval lval, pos))
  in
  let read_call =
    match bt with
    | AST.TInt  -> ReadInt
    | AST.TBool -> ReadBool
  in
  let (id, slot_num) =
    match lval with
    | AST.LId    (id, _)      -> (id, Sym.get_lid_slot_num symtbl proc_id id)
    | AST.LField (lfield, id) ->
        (id, Sym.get_lfield_slot_num symtbl proc_id (lfield, id))
  in
  match Sym.get_proc_var_scope symtbl proc_id id pos with
  | Sym.SDecl
  | Sym.SParamVal -> [Store (StackSlot slot_num, Reg 0);
                      CallBuiltin read_call]
  | Sym.SParamRef -> [StoreIndirect (Reg 0, Reg 0);
                      Load (Reg 0, StackSlot slot_num);
                      CallBuiltin read_call]

(* ========================= Expression Evaluation ========================== *)

(* Generate code for an integer literal expression *)
let gen_int_expr_code load_reg i =
  [IntConst (load_reg, i)]

(* Generate code for a boolean literal expression *)
let gen_bool_expr_code load_reg b =
  match b with
  | true  -> [IntConst (load_reg, 1)]
  | false -> [IntConst (load_reg, 0)]

(* Generate code for an lvalue expression evaluation *)
let gen_lval_code symtbl proc_id load_reg lval =
  let (scope, slot_num) =
    match lval with
    | AST.LField (lval, id) ->
        let pos = AST.get_lval_pos lval in
        let scope = Sym.get_proc_var_scope symtbl proc_id id pos in
        let slot_num = Sym.get_lfield_slot_num symtbl proc_id (lval, id) in
        (scope, slot_num)
    | AST.LId (id, pos)       ->
        let scope = Sym.get_proc_var_scope symtbl proc_id id pos in
        let slot_num = Sym.get_lid_slot_num symtbl proc_id id in
        (scope, slot_num)
  in
  match scope with
  | Sym.SDecl
  | Sym.SParamVal -> [Load (load_reg, StackSlot slot_num)]
  | Sym.SParamRef -> [LoadIndirect (load_reg, load_reg)  ;
                      Load (load_reg, StackSlot slot_num)]

(* Generate IR code for a unary operation expression *)
let rec gen_unop_code symtbl proc_id load_reg unop expr =
  let subexpr_code   = gen_expr_code symtbl proc_id load_reg expr in
  let operation_code =
    match unop with
    | AST.Op_not   -> [Not (load_reg, load_reg)]
    | AST.Op_minus ->
        let (Reg r) = load_reg in
        [MulInt (Reg r, Reg r, Reg (r+1));
         IntConst (Reg (r+1), -1)]
  in
  operation_code @ subexpr_code

(* Generate code for a binary operation expression *)
and
gen_binop_code symtbl proc_id load_reg binop lexpr rexpr =
  let Reg r      = load_reg in
  let lexpr_code = gen_expr_code symtbl proc_id (Reg r)     lexpr in
  let rexpr_code = gen_expr_code symtbl proc_id (Reg (r+1)) rexpr in
  let operation_code =
    match binop with
    (* Integer operations *)
    | AST.Op_add -> [AddInt (Reg r, Reg r, Reg (r+1))]
    | AST.Op_sub -> [SubInt (Reg r, Reg r, Reg (r+1))]
    | AST.Op_mul -> [MulInt (Reg r, Reg r, Reg (r+1))]
    | AST.Op_div -> [DivInt (Reg r, Reg r, Reg (r+1))]
    (* Integer comparison operations *)
    | AST.Op_eq  -> [CmpEqInt  (Reg r, Reg r, Reg (r+1))]
    | AST.Op_neq -> [CmpNeqInt (Reg r, Reg r, Reg (r+1))]
    | AST.Op_gt  -> [CmpGtInt  (Reg r, Reg r, Reg (r+1))]
    | AST.Op_geq -> [CmpGeqInt (Reg r, Reg r, Reg (r+1))]
    | AST.Op_lt  -> [CmpLtInt  (Reg r, Reg r, Reg (r+1))]
    | AST.Op_leq -> [CmpLeqInt (Reg r, Reg r, Reg (r+1))]
    (* Boolean binops *)
    | AST.Op_and -> [And (Reg r, Reg r, Reg (r+1))]
    | AST.Op_or  -> [Or  (Reg r, Reg r, Reg (r+1))]
  in
  operation_code @ rexpr_code @ lexpr_code

(*  Generate code for an expression
    symtbl: context symbol table for function
    proc_id: context procedure for function
    load_reg: put resulting value in this register
    expr: expression in question
    return: array of type bean_code_generate.instr
  *)
and
gen_expr_code symtbl proc_id load_reg expr =
  match expr with
  | AST.Eint  (i, _)          -> gen_int_expr_code load_reg i
  | AST.Ebool (b, _)          -> gen_bool_expr_code load_reg b
  | AST.Elval (lval, _)       -> gen_lval_code symtbl proc_id load_reg lval
  | AST.Eunop (unop, expr, _) ->
      gen_unop_code symtbl proc_id load_reg unop expr
  | AST.Ebinop (lexpr, binop, rexpr, _) ->
      gen_binop_code symtbl proc_id load_reg binop lexpr rexpr

(* ============================== Assignment ================================ *)

(* Stores the value of reg into slot, supports value and reference storing *)
let asgn_primitive symtbl proc_id reg scope slot expr =
  let slot_num =
    match !slot with
    | Some num -> num
    | None     -> raise (Unsupported "Slot not assigned")
  in
  let expr_code = gen_expr_code symtbl proc_id reg expr in
  let asgn_code =
    match scope with
    | Sym.SDecl
    | Sym.SParamVal -> [Store (StackSlot slot_num, reg)]
    | Sym.SParamRef -> [StoreIndirect (reg, reg)      ;
                        Load (reg, StackSlot slot_num)]
  in
  asgn_code @ expr_code

(* Stores the value of reg into the slot determined by the fields id *)
let rec asgn_field symtbl proc_id reg scope field_tbl (id, rval, _) code =
  let (type_sym, slot) =
    try
      Hashtbl.find field_tbl id
    with
    | Not_found -> raise (Unsupported "No such field in the struct")
  in
  let asgn_code =
    match (type_sym, rval) with
    | (Sym.STBeantype _, AST.Rexpr expr) ->
        asgn_primitive symtbl proc_id reg scope slot expr
    | (Sym.STFieldStruct subfield_tbl, AST.Rstruct rasgns) ->
        let go = asgn_field symtbl proc_id reg scope subfield_tbl in
        List.fold_right go rasgns []
    | _ -> raise (Unsupported "No such field in the struct")
  in
  (asgn_code @ code)

(* Assign the value stores in reg to a struct *)
let gen_struct_assign_code symtbl proc_id reg lval rstruct =
  let pos      = AST.get_lval_pos lval in
  let scope    = Sym.get_lval_scope symtbl proc_id lval pos in
  let type_sym = Sym.get_lval_type symtbl proc_id lval in
  match type_sym with
  | Sym.STBeantype _ ->
      raise (Unsupported "Can't assign fields on a primitive value")
  | Sym.STFieldStruct field_tbl ->
      let go = asgn_field symtbl proc_id reg scope field_tbl in
      List.fold_right go rstruct []

let gen_lval_primitive_asgn reg (lscope, lslot) (rscope, rslot) =
  let lslot_num =
    match !lslot with
    | Some snum -> snum
    | None      -> raise (Unsupported "No slot allocated to lval")
  in
  let rslot_num =
    match !rslot with
    | Some snum -> snum
    | None      -> raise (Unsupported "No slot allocated to rlval")
  in
  match (lscope, rscope) with
  | (Val, Val) 
  | (Ref, Ref) -> [Store (StackSlot lslot_num, reg);
                   Load  (reg, StackSlot rslot_num)]
  | (Val, Ref) -> [Store (StackSlot lslot_num, reg);
                   LoadIndirect (reg, reg);
                   Load  (reg, StackSlot rslot_num)]
  | (Ref, Val) -> [Store (StackSlot lslot_num, reg);
                   LoadAddress (reg, StackSlot rslot_num)]

let gen_assign_lval_code symtbl proc_id lval rlval =
  let lpos = AST.get_lval_pos lval in
  let rpos = AST.get_lval_pos rlval in
  let lscope = get_pass_type (Sym.get_lval_scope symtbl proc_id lval lpos)  in
  let rscope = get_pass_type (Sym.get_lval_scope symtbl proc_id rlval rpos) in
  let (l_tsym, lslot) = Sym.get_lval_sym symtbl proc_id lval  in
  let (r_tsym, rslot) = Sym.get_lval_sym symtbl proc_id rlval in
  let rec field_asgn lfields field_id (rf_tsym, rf_slot) code =
    let (lf_tsym, lf_slot) =
      try
        Hashtbl.find lfields field_id
      with
      | Not_found -> raise (Unsupported "No such field in lval for assignment")
    in
    match (lf_tsym, rf_tsym) with
    | (Sym.STBeantype _, Sym.STBeantype _) ->
        let asgn_code =
          gen_lval_primitive_asgn (Reg 0) (lscope, lf_slot) (rscope, rf_slot)
        in
        asgn_code @ code
    | (Sym.STFieldStruct lsubfields, Sym.STFieldStruct rsubfields) ->
        Hashtbl.fold (field_asgn lsubfields) rsubfields code
    | _ ->
        let pos = AST.get_lval_pos lval in
        raise (Sem.Type_error ("Bad unchecked lval assign type error", pos))
  in
  match (l_tsym, r_tsym) with
  | (Sym.STBeantype _, Sym.STBeantype _) ->
      gen_lval_primitive_asgn (Reg 0) (lscope, lslot) (rscope, rslot)
  | (Sym.STFieldStruct lfields, Sym.STFieldStruct rfields) ->
      Hashtbl.fold (field_asgn lfields) rfields []
  | _ ->
      let pos = AST.get_lval_pos lval in
      raise (Sem.Type_error ("Bad unchecked lval assign type error", pos))

(* stores the value of rval into lval, handles primitives and structs *)
let gen_assign_code symtbl proc_id lval rval =
  let lid_asgn id =
    let pos = AST.get_lval_pos lval in
    let slot_num = Sym.get_lid_slot_num symtbl proc_id id in
    match Sym.get_proc_var_scope symtbl proc_id id pos with
    | Sym.SDecl
    | Sym.SParamVal -> [Store (StackSlot slot_num, Reg 0)]
    | Sym.SParamRef -> [StoreIndirect (Reg 1, Reg 0)    ;
                        Load (Reg 1, StackSlot slot_num)]
  in
  let lfield_asgn (lval, id) =
    let pos = AST.get_lval_pos lval in
    let slot_num = Sym.get_lfield_slot_num symtbl proc_id (lval, id) in
    match Sym.get_proc_var_scope symtbl proc_id id pos with
    | Sym.SDecl
    | Sym.SParamVal -> [Store (StackSlot slot_num, Reg 0) ]
    | Sym.SParamRef -> [StoreIndirect (Reg 1, Reg 0)    ;
                        Load (Reg 1, StackSlot slot_num)]
  in
  match rval with
  | AST.Rstruct rstruct ->
      gen_struct_assign_code symtbl proc_id (Reg 0) lval rstruct
  (* TODO An Rexpr might be an lval with a compound type... *)
  | AST.Rexpr expr ->
      match expr with
      | AST.Elval (rlval, _) -> gen_assign_lval_code symtbl proc_id lval rlval
      | _ ->
        let expr_code = gen_expr_code symtbl proc_id (Reg 0) expr in
        let asgn_code =
          match lval with
          | AST.LId (id, _) -> lid_asgn id
          | AST.LField lval -> lfield_asgn lval
        in
        asgn_code @ expr_code

(* ================================ IO Write ================================ *)

(* Generate code to print a given bean type *)
let gen_bt_write_code bt =
  match bt with
  | AST.TInt  -> [CallBuiltin PrintInt]
  | AST.TBool -> [CallBuiltin PrintBool]

(* Generate code for a write statement *)
let gen_write_code symtbl proc_id wrt =
  let print_reg = Reg 0 in
  match wrt with
  | AST.WString str ->
      [CallBuiltin PrintString; StringConst (print_reg, str)]
  | AST.WExpr expr ->
      let expr_code  = gen_expr_code symtbl proc_id print_reg expr in
      let expr_type  = get_expr_type symtbl proc_id expr in
      let print_code =
        match expr_type with
        | Sym.STBeantype bt -> gen_bt_write_code bt
        | _ -> raise (Unsupported "Only primitive Bean types can be printed")
      in
      print_code @ expr_code

(* ========================== Subfunction Calling =========================== *)

(* Generate code to deal with passing of
* any type of argument into a procedure *)
let gen_arg_pass_code callee_scope caller_scope arg_num (t_sym, slot) =
  (* Loading functions *)
  (* Caller holds value, callee takes value *)
  let gen_val_val_pass argn slotn = [Load (Reg argn, StackSlot slotn)] in
  (* Caller holds ref, callee takes ref *)
  let gen_ref_ref_pass argn slotn = gen_val_val_pass argn slotn        in
  (* Caller holds ref, callee takes value *)
  let gen_ref_val_pass argn slotn = [LoadIndirect (Reg argn, Reg argn);
                                     Load (Reg argn, StackSlot slotn)]
  in
  (* Caller holds value, callee takes ref *)
  let gen_val_ref_pass argn slotn = [LoadAddress (Reg argn, StackSlot slotn)] in
  let gen_pass_code argn slotn =
    match (get_pass_type caller_scope, get_pass_type callee_scope) with
    | (Val, Val) -> gen_val_val_pass argn slotn
    | (Val, Ref) -> gen_val_ref_pass argn slotn
    | (Ref, Val) -> gen_ref_val_pass argn slotn
    | (Ref, Ref) -> gen_ref_ref_pass argn slotn
  in
  (* Folder function for argument field loading *)
  let rec gen_field_proc_pass _ (type_sym, field_slot) (argn, code) =
    match type_sym with
    | Sym.STFieldStruct fields ->
        Hashtbl.fold gen_field_proc_pass fields (argn, code)
    | Sym.STBeantype bt ->
        let slot_num =
          match !field_slot with
          | Some num -> num
          | None      ->
              raise (Unsupported "No slot allocated to beantyped field")
        in
        let arg_code = gen_pass_code argn slot_num in
        (argn+1, arg_code @ code)
  in
  (* Main function body -- deals with either simple or struct values *)
  match t_sym with
  | Sym.STBeantype _ ->
      let slot_num =
        match !slot with
        | Some num -> num
        | None     ->
            raise (Unsupported "No slot allocated to beantyped arg")
      in
      (arg_num+1, gen_pass_code arg_num slot_num)
  | Sym.STFieldStruct fields ->
      Hashtbl.fold gen_field_proc_pass fields (arg_num, [])

(*
  generates code to load a pointer to an arg in arg_num
  symtbl: context symbol table for program
  caller_id: proc ident which is calling the new proc
  arg_num: register number to load the pointer into
  arg: expr->Elval which contains value to be pointed to
  return: [instr]
*)
let gen_proc_load_ref symtbl caller_id arg_num arg =
  match arg with
  | AST.Ebool  _ | AST.Eint   _
  | AST.Eunop  _ | AST.Ebinop _
      -> raise (Unsupported "Cannot accept expression as ref arg")
  | AST.Elval (lval, pos) ->
      let (scope, slot_num) =
        match lval with
        | AST.LField (lval, id) ->
            let slot_num =
              Sym.get_lfield_slot_num symtbl caller_id (lval, id)
            in
            let scope = Sym.get_proc_var_scope symtbl caller_id id pos in
            (scope, slot_num)
        | AST.LId (id, _) ->
            let slot_num = Sym.get_lid_slot_num symtbl caller_id id in
            let scope    = Sym.get_proc_var_scope symtbl caller_id id pos in
            (scope, slot_num)
      in
      match scope with
      | Sym.SDecl
      | Sym.SParamVal -> [LoadAddress (arg_num, StackSlot slot_num)]
      | Sym.SParamRef -> [Load (arg_num, StackSlot slot_num)]

let gen_proc_call_code symtbl caller_id callee_id exprs pos =
  let gen_lval_pass_code param_id lval (arg_num, code) =
    match lval with
    | AST.LId (id, pos) ->
      let callee_scope = Sym.get_proc_var_scope symtbl callee_id param_id pos in
      let (type_sym, caller_scope, slot, _) =
        Sym.get_var_sym symtbl caller_id id
      in
      let (new_arg, load_code) =
        gen_arg_pass_code callee_scope caller_scope arg_num (type_sym, slot)
      in
      (new_arg, load_code @ code)
    | AST.LField (lval, id) ->
        let pos = AST.get_lval_pos lval in
        let callee_scope =
          Sym.get_proc_var_scope symtbl callee_id param_id pos
        in
        let caller_scope = Sym.get_proc_var_scope symtbl caller_id id pos in
        let field_sym    =
          Sym.get_lval_sym symtbl caller_id (AST.LField (lval, id)) in
        let (new_arg, load_code) =
          gen_arg_pass_code callee_scope caller_scope arg_num field_sym
        in
        (new_arg, load_code @ code)
  in
  let proc_label = Sym.get_proc_label symtbl callee_id pos in
  let params     = Sym.get_param_list symtbl callee_id in
  let load_arg (arg_num, code) (expr, param_id) =
    match expr with
    | AST.Elval (lval, _) -> gen_lval_pass_code param_id lval (arg_num, code)
    | _                   ->
        let arg_code = gen_expr_code symtbl caller_id (Reg arg_num) expr in
        (arg_num+1, arg_code @ code)
  in
  let param_args = List.combine exprs params in
  let (arg_num, arg_code) = List.fold_left load_arg (0, []) param_args in
  let call_code = [Call (Label proc_label)] in
  call_code @ arg_code

let gen_bt_param_code arg_num slot_num slot =
  slot := Some slot_num;
  (arg_num+1, slot_num+1, [Store (StackSlot slot_num, Reg arg_num)])

let rec gen_field_param_code scope id (t_sym, slot) (arg_num, slot_num, code) =
  let (new_arg, new_slot, field_code) =
    match t_sym with
    | Sym.STBeantype    _      -> gen_bt_param_code arg_num slot_num slot
    | Sym.STFieldStruct fields ->
        let go = gen_field_param_code scope in
        Hashtbl.fold go fields (arg_num, slot_num, [])
  in
  (new_arg, new_slot, field_code @ code)

(* Generate code for a single parameter pass *)
let gen_param_code symtbl proc_id (arg_num, frame_size, code) param =
  let (_, _, id, _) = param in
  Sem.check_param_name symtbl proc_id id;
  let (param_type, param_scope, slot, _) = Sym.get_var_sym symtbl proc_id id in
  let (num_args, new_frame_size, param_code) =
    match param_type with
    | Sym.STBeantype _ ->
        gen_bt_param_code arg_num frame_size slot
    | Sym.STFieldStruct fields ->
        let go = gen_field_param_code param_scope in
        Hashtbl.fold go fields (arg_num, frame_size, [])
  in
  (num_args, new_frame_size, param_code @ code)

(* ============================= Control Flow =============================== *)

(* Generate labels for an if statement *)
let make_if_labels label_num =
  let after_label = Label ("if_after" ^ string_of_int label_num) in
  (label_num+1, after_label)

(* Generate labels for an in-else statment *)
let make_ifel_labels label_num =
  let else_label  = Label ("ifel_else"  ^ string_of_int label_num) in
  let after_label = Label ("ifel_after" ^ string_of_int label_num) in
  (label_num+1, after_label, else_label)

(* Generate labels for a do-while statement *)
let make_while_labels label_num =
  let cond_label  = Label ("while_cond"  ^ string_of_int label_num) in
  let after_label = Label ("while_after" ^ string_of_int label_num) in
  (label_num+1, after_label, cond_label)

(* Generate labels for a proc, eg. call proc_main *)
let assign_proc_label symtbl (proc_id, _, _, _) () =
  let label_str = "proc_" ^ proc_id in
  Sym.set_proc_label symtbl proc_id label_str

(* Generate if-statement code *)
let rec gen_if_code symtbl proc_id label_num expr stmts =
  let (new_label, after_label) = make_if_labels label_num in
  let cond_reg    = Reg 0 in
  let expr_code   = gen_expr_code symtbl proc_id cond_reg expr in
  let branch_code = [BranchOnFalse (cond_reg, after_label)] in
  let stmt_fold stmt acc = gen_stmt_code symtbl proc_id acc stmt in
  let (final_label, stmts_code) =
    List.fold_right stmt_fold stmts (new_label, [])
  in
  let after_code = [BlockLabel after_label] in
  (final_label, after_code @ stmts_code @ branch_code @ expr_code)

(* Generate if-else-statement code *)
and
gen_ifelse_code symtbl proc_id label_num expr if_stmts el_stmts =
  let (new_label, after_label, else_label) = make_ifel_labels label_num in
  let cond_reg    = Reg 0 in
  let expr_code   = gen_expr_code symtbl proc_id cond_reg expr in
  let branch_code = [BranchOnFalse (cond_reg, else_label)] in
  let stmt_fold stmt acc = gen_stmt_code symtbl proc_id acc stmt in
  let (label_num1, if_stmts_code) =
    List.fold_right stmt_fold if_stmts (new_label, [])
  in
  let before_else_code =
    [BlockLabel else_label; BranchUncond after_label]
  in
  let (label_num2, else_code) =
    List.fold_right stmt_fold el_stmts (label_num1, [])
  in
  let after_code = [BlockLabel after_label] in
  let code =
    after_code
    @ else_code
    @ before_else_code
    @ if_stmts_code
    @ branch_code
    @ expr_code
  in
  (label_num2, code)

(* Generate while-statement code *)
and
gen_while_code symtbl proc_id label_num expr stmts =
  let (new_label, after_label, cond_label) = make_while_labels label_num in
  let cond_reg    = Reg 0 in
  let cond_code   = [BlockLabel cond_label] in
  let expr_code   = gen_expr_code symtbl proc_id cond_reg expr in
  let branch_code = [BranchOnFalse (cond_reg, after_label)] in
  let stmt_fold stmt acc = gen_stmt_code symtbl proc_id acc stmt in
  let (final_label, stmt_code) =
    List.fold_right stmt_fold stmts (new_label, [])
  in
  let while_end_code = [BranchUncond cond_label] in
  let after_code     = [BlockLabel  after_label] in
  let code =
    after_code
    @ while_end_code
    @ stmt_code
    @ branch_code
    @ expr_code
    @ cond_code
  in
  (final_label, code)

(* Generate code for a single statement *)
and
gen_stmt_code symtbl proc_id (label_num, code) stmt =
  Sem.check_stmt symtbl proc_id stmt;
  let (new_label, stmt_code) =
    match stmt with
    | AST.Write wrt ->
        (label_num, gen_write_code symtbl proc_id wrt)
    | AST.Assign (lval, rval, _) ->
        (label_num, gen_assign_code symtbl proc_id lval rval)
    | AST.Read lval ->
        (label_num, gen_read_code symtbl proc_id lval)
    | AST.If (expr, stmts) ->
        gen_if_code symtbl proc_id label_num expr stmts
    | AST.IfElse (expr, if_stmts, el_stmts) ->
        gen_ifelse_code symtbl proc_id label_num expr if_stmts el_stmts
    | AST.While (expr, stmts) ->
        gen_while_code symtbl proc_id label_num expr stmts
    | AST.ProcCall (callee_id, exprs, pos) ->
        (label_num, gen_proc_call_code symtbl proc_id callee_id exprs pos)
  in
  (new_label, stmt_code @ code)

(* ================================ Procedures ============================== *)

(* Generate code for a single procedure *)
let gen_proc_code symtbl (label_num, code) proc =
  let (proc_id, params, (decls, stmts), pos) = proc in
  let label_str = Sym.get_proc_label symtbl proc_id pos in
  let frame_size = 0 in
  Sym.set_proc_label symtbl proc_id label_str;
  (* Define curried folder functions *)
  let param_gen = gen_param_code symtbl proc_id in
  let decl_gen  = gen_decl_code  symtbl proc_id in
  let stmt_gen  = gen_stmt_code  symtbl proc_id in
  (* Do the recursive code generation *)
  let (arg_num, frame_size1, code1) =
    List.fold_left param_gen (0, frame_size, []) params
  in
  let (frame_size2, code2) =
    List.fold_left decl_gen (frame_size1, code1) decls
  in
  let (labels_used, body_code) =
    List.fold_left stmt_gen (label_num, code2) stmts
  in
  (* Create the function prologue and epilogue *)
  let label    =  Label label_str in
  let prologue = [PushStackFrame frame_size2; BlockLabel label] in
  let epilogue = [Return; PopStackFrame frame_size2] in
  (* Make the code backwards so it can be reversed at the end *)
  let proc_code = epilogue @ body_code @ prologue in
  (labels_used, proc_code @ code)

(* ========================================================================== *)
(* ============================= MAIN FUNCTION ============================== *)
(* ========================================================================== *)

(* Generate code for a bean program *)
let gen_code symtbl prog =
  Sem.check_has_main symtbl;
  let procs = prog.AST.procs in
  (* Standard Oz prelude: call proc_main and then halt *)
  let prelude = [Call (Label "proc_main"); Halt] in
  (* Assign labels to procedures in advance to allow forward calls *)
  List.fold_right (assign_proc_label symtbl) procs ();
  let (_, prog) = List.fold_left (gen_proc_code symtbl) (0, []) procs in
  prelude @ List.rev prog

let gen_code_checked symtbl prog =
  try
    gen_code symtbl prog
  with
  | Sem.Type_error (msg, pos) ->
      raise (Sem.Semantic_error (msg, pos))
  | Sem.Arity_mismatch (id, pos) ->
      raise (Sem.Semantic_error
        (id^" is called with the wrong number of arguments", pos))
  | Sem.Assign_type_mismatch (l_type_sym, r_type_sym, pos) ->
      (* TODO figure out how to print things based on type sym? *)
      raise (Sem.Semantic_error ("assignment type problem", pos))
  | Sem.Reference_pass (id, pos) ->
      raise (Sem.Semantic_error (id^" cannot be passed by reference", pos))
  | Sem.Read_struct (id, pos) ->
      raise (Sem.Semantic_error (id^" is a structure and cannot be read", pos))
  | Sem.Write_struct (id, pos) ->
      raise (Sem.Semantic_error
        (id^" is a structure and cannot be written", pos))
  | Sem.Var_name_is_type (id, pos) ->
      raise (Sem.Semantic_error (id^" is already defined as a type", pos))
  | Sem.Var_name_is_param (id, pos) ->
      raise (Sem.Semantic_error (id^" is already defined as a paramater", pos))
  | Sem.Param_name_is_type (id, pos) ->
      raise (Sem.Semantic_error (id^" is already defined as a type", pos))
  | Sem.Main_has_nonzero_arity ->
      let pos = Sym.get_proc_pos symtbl "main" in
      raise (Sem.Semantic_error ("Procedure main has non-zero arity", pos))
  | Sym.Duplicate_type (id, pos) ->
      raise (Sym.Definition_error ("The type "^id^" is already defined", pos))
  | Sym.Undefined_type (id, pos) ->
      raise (Sym.Definition_error ("The type "^id^" is not defined", pos))
  | Sym.Duplicate_proc (id, pos) ->
      raise (Sym.Definition_error
        ("The procedure "^id^" is already defined", pos))
  | Sym.Undefined_proc (id, pos) ->
      raise (Sym.Definition_error ("The procedure "^id^" is not defined", pos))
  | Sym.Duplicate_param (id, pos) ->
      raise (Sym.Definition_error
        ("The parameter "^id^" is already declared", pos))
  | Sym.Duplicate_decl (id, pos) ->
      raise (Sym.Definition_error
        ("The variable "^id^" is already declared", pos))
  | Sym.Undefined_variable (id, pos) ->
      raise (Sym.Definition_error
        ("The variable "^id^" is not defined anywhere", pos))
  | Sym.Duplicate_field (id, pos) ->
      raise (Sym.Definition_error ("The field "^id^" is already defined", pos))
  (*| Sym.Undefined_field (id, pos) ->
      raise (Sym.Definition_error ("The field "^id^" is not defined", pos))
*)
============================================
src/bean_intermediate_code.mli
16:38:20_Friday_20_May_2016
============================================
(* A register *)
type reg = Reg of int

(* A slot in the activation record stack *)
type stack_slot = StackSlot of int

(* An instruction block label *)
type label = Label of string

(* Builtin functions *)
type builtin =
  | ReadInt
  | ReadBool
  | PrintInt
  | PrintBool
  | PrintString

(* Machine instructions *)
type instr =
  (* Stack manipulation *)
  | PushStackFrame of int
  | PopStackFrame  of int
  (* Register store/load *)
  | Load           of reg        * stack_slot
  | Store          of stack_slot * reg
  | LoadAddress    of reg        * stack_slot
  | LoadIndirect   of reg        * reg
  | StoreIndirect  of reg        * reg
  (* Register immediate operations *)
  | IntConst       of reg * int
  | StringConst    of reg * string
  (* Integer arithmetic operations *)
  | AddInt         of reg * reg * reg
  | SubInt         of reg * reg * reg
  | MulInt         of reg * reg * reg
  | DivInt         of reg * reg * reg
  (* Address offset operations *)
  | AddOffset      of reg * reg * reg
  | SubOffset      of reg * reg * reg
  (* Integer comparison operations *)
  | CmpEqInt       of reg * reg * reg
  | CmpNeqInt      of reg * reg * reg
  | CmpGtInt       of reg * reg * reg
  | CmpGeqInt      of reg * reg * reg
  | CmpLtInt       of reg * reg * reg
  | CmpLeqInt      of reg * reg * reg
  (* Boolean arithmetic operations *)
  | And            of reg * reg * reg
  | Or             of reg * reg * reg
  | Not            of reg * reg
  (* Move *)
  | Move           of reg * reg
  (* Branch instructions *)
  | BranchOnTrue   of reg * label
  | BranchOnFalse  of reg * label
  | BranchUncond   of label
  (* Calls *)
  | Call           of label
  | CallBuiltin    of builtin
  | Return
  (* Emulator halt *)
  | Halt
  (* A label pseudo-instruction *)
  | BlockLabel     of label
  (* Debug instructions *)
  | DebugReg       of reg
  | DebugSlot      of stack_slot
  | DebugStack

type code = instr list

val gen_code_checked: Bean_symtbl.t -> Bean_ast.t -> instr list
============================================
src/Makefile.depend
16:38:20_Friday_20_May_2016
============================================
bean.cmo : bean_symtbl.cmi bean_semantic.cmi bean_pprint.cmi bean_parse.cmi \
    bean_oz.cmi bean_lex.cmo bean_ast.cmi
bean.cmx : bean_symtbl.cmx bean_semantic.cmx bean_pprint.cmx bean_parse.cmx \
    bean_oz.cmx bean_lex.cmx bean_ast.cmx
bean_ast.cmi :
bean_parse.cmi : bean_ast.cmi
bean_pprint.cmi : bean_ast.cmi
bean_symtbl.cmi : bean_ast.cmi
bean_semantic.cmi : bean_symtbl.cmi bean_ast.cmi
bean_intermediate_code.cmi : bean_symtbl.cmi bean_ast.cmi
bean_oz.cmi : bean_symtbl.cmi bean_ast.cmi
bean_ast.cmo : bean_ast.cmi
bean_ast.cmx : bean_ast.cmi
bean_lex.cmo : bean_parse.cmi
bean_lex.cmx : bean_parse.cmx
bean_parse.cmo : bean_ast.cmi bean_parse.cmi
bean_parse.cmx : bean_ast.cmx bean_parse.cmi
bean_pprint.cmo : bean_ast.cmi bean_pprint.cmi
bean_pprint.cmx : bean_ast.cmx bean_pprint.cmi
bean_symtbl.cmo : bean_ast.cmi bean_symtbl.cmi
bean_symtbl.cmx : bean_ast.cmx bean_symtbl.cmi
bean_semantic.cmo : bean_symtbl.cmi bean_pprint.cmi bean_ast.cmi \
    bean_semantic.cmi
bean_semantic.cmx : bean_symtbl.cmx bean_pprint.cmx bean_ast.cmx \
    bean_semantic.cmi
bean_intermediate_code.cmo : bean_symtbl.cmi bean_semantic.cmi bean_ast.cmi \
    bean_intermediate_code.cmi
bean_intermediate_code.cmx : bean_symtbl.cmx bean_semantic.cmx bean_ast.cmx \
    bean_intermediate_code.cmi
bean_oz.cmo : bean_intermediate_code.cmi bean_oz.cmi
bean_oz.cmx : bean_intermediate_code.cmx bean_oz.cmi
bean.cmo : bean_symtbl.cmi bean_semantic.cmi bean_pprint.cmi bean_parse.cmi \
    bean_oz.cmi bean_lex.cmo bean_ast.cmi
bean.cmx : bean_symtbl.cmx bean_semantic.cmx bean_pprint.cmx bean_parse.cmx \
    bean_oz.cmx bean_lex.cmx bean_ast.cmx
============================================
src/bean_lex.mll
16:38:20_Friday_20_May_2016
============================================
(* =========================================================== *)
(* Lexer for the bean language specification                   *)
(* -----------------------------------------                   *)
(* Reads from an OCaml in_channel and returns a                *)
(* tokenised version for processing by bean_parse.mly          *)
(* =========================================================== *)

{
module L = Lexing

open Bean_parse

(* Defines helpful error messages *)
exception Lex_error of string

(* Set the lexer filename *)
let set_lex_file filename lexbuf =
  lexbuf.L.lex_curr_p <- { lexbuf.L.lex_curr_p with
                           L.pos_fname = filename }


(* Retrieve the lexer's line and column number for error reporting *)
let get_lex_pos lexbuf =
  let pos   = lexbuf.L.lex_curr_p in
  let fname = pos.L.pos_fname in
  let line  = pos.L.pos_lnum  in
  let col   = pos.L.pos_cnum - pos.L.pos_bol + 1 in
  (fname, line, col)
}

let digit   = ['0' - '9']
let alpha   = ['a' - 'z' 'A' - 'Z' '_']
let alprime = alpha | '\''
let ident   = alpha alprime*

(* the token rule, dictates how to tokenise input*)
rule token = parse
  | [' ' '\t']            { token lexbuf }     (* skip blanks *)
  | '#'[^'\n']*           { token lexbuf }     (* ignore comments *)
  | '\n'                  { Lexing.new_line lexbuf ; token lexbuf }
  | '-'?['0'-'9']+ as lxm { INT_CONST(int_of_string lxm) }

  (* keywords *)
  | "bool"    { BOOL }
  | "int"     { INT }
  | "true"    { BOOL_CONST true }
  | "false"   { BOOL_CONST false }
  | "read"    { READ }
  | "write"   { WRITE }
  | "if"      { IF }
  | "then"    { THEN }
  | "else"    { ELSE }
  | "fi"      { FI }
  | "while"   { WHILE }
  | "do"      { DO }
  | "od"      { OD }
  | "val"     { VAL }
  | "ref"     { REF }
  | "proc"    { PROC }
  | "end"     { END }
  | "typedef" { TYPEDEF }
  | "and"     { AND }
  | "or"      { OR }
  | "not"     { NOT }

  (* Begin a string -- see second lex rule *)
  | '"'  { read_string (Buffer.create 20) lexbuf }

  (* Other syntactic elements *)
  | ','  { COMMA }
  | '.'  { DOT }
  | '('  { LPAREN }
  | ')'  { RPAREN }
  | '{'  { LBRACE }
  | '}'  { RBRACE }

  (* Operators *)
  | ":=" { ASSIGN }
  | '='  { EQ }
  | "!=" { NEQ }
  | '<'  { LT }
  | "<=" { LEQ }
  | '>'  { GT }
  | ">=" { GEQ }
  | '+'  { PLUS }
  | '-'  { MINUS }
  | '*'  { MUL }
  | '/'  { DIV }
  | ':'  { COLON }
  | ';'  { SEMICOLON }

  (* Idents have a low rule to not conflict with keywords *)
  | ident as lxm { IDENT lxm }
  | eof          { EOF }
  | _            { raise (Lex_error
                          ("Unknown symbol \""^(Lexing.lexeme lexbuf)^"\"")) }

(* read_string processes strings to ensure that contain only legal characters
   and that they are terminated, then returns them as a STR_CONST.            *)
and read_string buf =
  parse
  (* Terminate string *)
  | '"'           { STR_CONST (Buffer.contents buf) }
  (* Legal characters *)
  | [^ '"' '\n' '\t']  { Buffer.add_string buf (Lexing.lexeme lexbuf);
                         read_string buf lexbuf }
  (* Weird characters are rejected *)
  | '\n' { raise (Lex_error ("Illegal newline in string")) }
  | '\t' { raise (Lex_error ("Illegal tab character in string")) }
  | _    { raise (Lex_error
                ("Illegal string character: \""^(Lexing.lexeme lexbuf)^"\"")) }
  (* Programs can't terminate with an open string *)
  | eof  { raise (Lex_error "End of file reached before string terminated") }
============================================
src/bean_parse.output
16:38:20_Friday_20_May_2016
============================================
   0  $accept : %entry% $end

   1  program : typedefs procs

   2  typedefs : typedefs typedef
   3           |

   4  typedef : TYPEDEF typespec IDENT

   5  beantype : BOOL
   6           | INT

   7  definedtype : IDENT

   8  typespec : beantype
   9           | definedtype
  10           | LBRACE fields RBRACE

  11  fields : fields COMMA field
  12         | field

  13  field : IDENT COLON typespec

  14  procs : procs proc
  15        | proc

  16  proc : PROC IDENT LPAREN RPAREN proc_body END
  17       | PROC IDENT LPAREN proc_params RPAREN proc_body END

  18  proc_params : proc_params COMMA proc_param
  19              | proc_param

  20  proc_param : pass_type typespec IDENT

  21  pass_type : VAL
  22            | REF

  23  proc_body : decls stmts

  24  decls : decls decl
  25        |

  26  decl : typespec IDENT SEMICOLON

  27  stmts : stmts stmt
  28        | stmt

  29  stmt : stmt_body SEMICOLON
  30       | IF expr THEN stmts FI
  31       | IF expr THEN stmts ELSE stmts FI
  32       | WHILE expr DO stmts OD

  33  stmt_body : proc_call
  34            | READ lvalue
  35            | WRITE writeable
  36            | lvalue ASSIGN rvalue

  37  proc_call : IDENT LPAREN exprs RPAREN

  38  exprs : exprs COMMA expr
  39        | expr
  40        |

  41  rvalue : expr
  42         | struct_init

  43  struct_init : LBRACE struct_assigns RBRACE

  44  struct_assigns : struct_assigns COMMA struct_assign
  45                 | struct_assign
  46                 |

  47  struct_assign : IDENT EQ rvalue

  48  lvalue : IDENT DOT lvalue
  49         | IDENT

  50  expr : literal
  51       | lvalue
  52       | binop
  53       | unop
  54       | LPAREN expr RPAREN

  55  literal : BOOL_CONST
  56          | INT_CONST

  57  binop : expr PLUS expr
  58        | expr MINUS expr
  59        | expr MUL expr
  60        | expr DIV expr
  61        | expr AND expr
  62        | expr OR expr
  63        | expr EQ expr
  64        | expr NEQ expr
  65        | expr LT expr
  66        | expr LEQ expr
  67        | expr GT expr
  68        | expr GEQ expr

  69  unop : MINUS expr
  70       | NOT expr

  71  writeable : expr
  72            | STR_CONST

  73  %entry% : '\001' program

state 0
	$accept : . %entry% $end  (0)

	'\001'  shift 1
	.  error

	%entry%  goto 2


state 1
	%entry% : '\001' . program  (73)
	typedefs : .  (3)

	.  reduce 3

	program  goto 3
	typedefs  goto 4


state 2
	$accept : %entry% . $end  (0)

	$end  accept


state 3
	%entry% : '\001' program .  (73)

	.  reduce 73


state 4
	program : typedefs . procs  (1)
	typedefs : typedefs . typedef  (2)

	PROC  shift 5
	TYPEDEF  shift 6
	.  error

	procs  goto 7
	typedef  goto 8
	proc  goto 9


state 5
	proc : PROC . IDENT LPAREN RPAREN proc_body END  (16)
	proc : PROC . IDENT LPAREN proc_params RPAREN proc_body END  (17)

	IDENT  shift 10
	.  error


state 6
	typedef : TYPEDEF . typespec IDENT  (4)

	IDENT  shift 11
	BOOL  shift 12
	INT  shift 13
	LBRACE  shift 14
	.  error

	typespec  goto 15
	beantype  goto 16
	definedtype  goto 17


state 7
	program : typedefs procs .  (1)
	procs : procs . proc  (14)

	PROC  shift 5
	$end  reduce 1

	proc  goto 18


state 8
	typedefs : typedefs typedef .  (2)

	.  reduce 2


state 9
	procs : proc .  (15)

	.  reduce 15


state 10
	proc : PROC IDENT . LPAREN RPAREN proc_body END  (16)
	proc : PROC IDENT . LPAREN proc_params RPAREN proc_body END  (17)

	LPAREN  shift 19
	.  error


state 11
	definedtype : IDENT .  (7)

	.  reduce 7


state 12
	beantype : BOOL .  (5)

	.  reduce 5


state 13
	beantype : INT .  (6)

	.  reduce 6


state 14
	typespec : LBRACE . fields RBRACE  (10)

	IDENT  shift 20
	.  error

	fields  goto 21
	field  goto 22


state 15
	typedef : TYPEDEF typespec . IDENT  (4)

	IDENT  shift 23
	.  error


state 16
	typespec : beantype .  (8)

	.  reduce 8


state 17
	typespec : definedtype .  (9)

	.  reduce 9


state 18
	procs : procs proc .  (14)

	.  reduce 14


state 19
	proc : PROC IDENT LPAREN . RPAREN proc_body END  (16)
	proc : PROC IDENT LPAREN . proc_params RPAREN proc_body END  (17)

	VAL  shift 24
	REF  shift 25
	RPAREN  shift 26
	.  error

	proc_params  goto 27
	proc_param  goto 28
	pass_type  goto 29


state 20
	field : IDENT . COLON typespec  (13)

	COLON  shift 30
	.  error


state 21
	typespec : LBRACE fields . RBRACE  (10)
	fields : fields . COMMA field  (11)

	COMMA  shift 31
	RBRACE  shift 32
	.  error


state 22
	fields : field .  (12)

	.  reduce 12


state 23
	typedef : TYPEDEF typespec IDENT .  (4)

	.  reduce 4


state 24
	pass_type : VAL .  (21)

	.  reduce 21


state 25
	pass_type : REF .  (22)

	.  reduce 22


state 26
	proc : PROC IDENT LPAREN RPAREN . proc_body END  (16)
	decls : .  (25)

	.  reduce 25

	proc_body  goto 33
	decls  goto 34


state 27
	proc : PROC IDENT LPAREN proc_params . RPAREN proc_body END  (17)
	proc_params : proc_params . COMMA proc_param  (18)

	COMMA  shift 35
	RPAREN  shift 36
	.  error


state 28
	proc_params : proc_param .  (19)

	.  reduce 19


state 29
	proc_param : pass_type . typespec IDENT  (20)

	IDENT  shift 11
	BOOL  shift 12
	INT  shift 13
	LBRACE  shift 14
	.  error

	typespec  goto 37
	beantype  goto 16
	definedtype  goto 17


state 30
	field : IDENT COLON . typespec  (13)

	IDENT  shift 11
	BOOL  shift 12
	INT  shift 13
	LBRACE  shift 14
	.  error

	typespec  goto 38
	beantype  goto 16
	definedtype  goto 17


state 31
	fields : fields COMMA . field  (11)

	IDENT  shift 20
	.  error

	field  goto 39


state 32
	typespec : LBRACE fields RBRACE .  (10)

	.  reduce 10


state 33
	proc : PROC IDENT LPAREN RPAREN proc_body . END  (16)

	END  shift 40
	.  error


state 34
	proc_body : decls . stmts  (23)
	decls : decls . decl  (24)

	IDENT  shift 41
	BOOL  shift 12
	INT  shift 13
	WRITE  shift 42
	READ  shift 43
	IF  shift 44
	WHILE  shift 45
	LBRACE  shift 14
	.  error

	typespec  goto 46
	beantype  goto 16
	definedtype  goto 17
	stmts  goto 47
	decl  goto 48
	stmt  goto 49
	stmt_body  goto 50
	proc_call  goto 51
	lvalue  goto 52


state 35
	proc_params : proc_params COMMA . proc_param  (18)

	VAL  shift 24
	REF  shift 25
	.  error

	proc_param  goto 53
	pass_type  goto 29


state 36
	proc : PROC IDENT LPAREN proc_params RPAREN . proc_body END  (17)
	decls : .  (25)

	.  reduce 25

	proc_body  goto 54
	decls  goto 34


state 37
	proc_param : pass_type typespec . IDENT  (20)

	IDENT  shift 55
	.  error


state 38
	field : IDENT COLON typespec .  (13)

	.  reduce 13


state 39
	fields : fields COMMA field .  (11)

	.  reduce 11


state 40
	proc : PROC IDENT LPAREN RPAREN proc_body END .  (16)

	.  reduce 16


state 41
	definedtype : IDENT .  (7)
	proc_call : IDENT . LPAREN exprs RPAREN  (37)
	lvalue : IDENT . DOT lvalue  (48)
	lvalue : IDENT .  (49)

	DOT  shift 56
	LPAREN  shift 57
	IDENT  reduce 7
	ASSIGN  reduce 49


state 42
	stmt_body : WRITE . writeable  (35)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	STR_CONST  shift 60
	IDENT  shift 61
	LPAREN  shift 62
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 65
	lvalue  goto 66
	writeable  goto 67
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 43
	stmt_body : READ . lvalue  (34)

	IDENT  shift 61
	.  error

	lvalue  goto 71


state 44
	stmt : IF . expr THEN stmts FI  (30)
	stmt : IF . expr THEN stmts ELSE stmts FI  (31)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 72
	lvalue  goto 66
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 45
	stmt : WHILE . expr DO stmts OD  (32)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 73
	lvalue  goto 66
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 46
	decl : typespec . IDENT SEMICOLON  (26)

	IDENT  shift 74
	.  error


state 47
	proc_body : decls stmts .  (23)
	stmts : stmts . stmt  (27)

	IDENT  shift 75
	WRITE  shift 42
	READ  shift 43
	IF  shift 44
	WHILE  shift 45
	END  reduce 23

	stmt  goto 76
	stmt_body  goto 50
	proc_call  goto 51
	lvalue  goto 52


state 48
	decls : decls decl .  (24)

	.  reduce 24


state 49
	stmts : stmt .  (28)

	.  reduce 28


state 50
	stmt : stmt_body . SEMICOLON  (29)

	SEMICOLON  shift 77
	.  error


state 51
	stmt_body : proc_call .  (33)

	.  reduce 33


state 52
	stmt_body : lvalue . ASSIGN rvalue  (36)

	ASSIGN  shift 78
	.  error


state 53
	proc_params : proc_params COMMA proc_param .  (18)

	.  reduce 18


state 54
	proc : PROC IDENT LPAREN proc_params RPAREN proc_body . END  (17)

	END  shift 79
	.  error


state 55
	proc_param : pass_type typespec IDENT .  (20)

	.  reduce 20


state 56
	lvalue : IDENT DOT . lvalue  (48)

	IDENT  shift 61
	.  error

	lvalue  goto 80


state 57
	proc_call : IDENT LPAREN . exprs RPAREN  (37)
	exprs : .  (40)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	NOT  shift 63
	MINUS  shift 64
	COMMA  reduce 40
	RPAREN  reduce 40

	expr  goto 81
	lvalue  goto 66
	exprs  goto 82
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 58
	literal : BOOL_CONST .  (55)

	.  reduce 55


state 59
	literal : INT_CONST .  (56)

	.  reduce 56


state 60
	writeable : STR_CONST .  (72)

	.  reduce 72


state 61
	lvalue : IDENT . DOT lvalue  (48)
	lvalue : IDENT .  (49)

	DOT  shift 56
	ASSIGN  reduce 49
	THEN  reduce 49
	DO  reduce 49
	COMMA  reduce 49
	RPAREN  reduce 49
	RBRACE  reduce 49
	OR  reduce 49
	AND  reduce 49
	EQ  reduce 49
	NEQ  reduce 49
	LT  reduce 49
	LEQ  reduce 49
	GT  reduce 49
	GEQ  reduce 49
	PLUS  reduce 49
	MINUS  reduce 49
	MUL  reduce 49
	DIV  reduce 49
	SEMICOLON  reduce 49


state 62
	expr : LPAREN . expr RPAREN  (54)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 83
	lvalue  goto 66
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 63
	unop : NOT . expr  (70)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 84
	lvalue  goto 66
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 64
	unop : MINUS . expr  (69)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 85
	lvalue  goto 66
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 65
	binop : expr . PLUS expr  (57)
	binop : expr . MINUS expr  (58)
	binop : expr . MUL expr  (59)
	binop : expr . DIV expr  (60)
	binop : expr . AND expr  (61)
	binop : expr . OR expr  (62)
	binop : expr . EQ expr  (63)
	binop : expr . NEQ expr  (64)
	binop : expr . LT expr  (65)
	binop : expr . LEQ expr  (66)
	binop : expr . GT expr  (67)
	binop : expr . GEQ expr  (68)
	writeable : expr .  (71)

	OR  shift 86
	AND  shift 87
	EQ  shift 88
	NEQ  shift 89
	LT  shift 90
	LEQ  shift 91
	GT  shift 92
	GEQ  shift 93
	PLUS  shift 94
	MINUS  shift 95
	MUL  shift 96
	DIV  shift 97
	SEMICOLON  reduce 71


state 66
	expr : lvalue .  (51)

	.  reduce 51


state 67
	stmt_body : WRITE writeable .  (35)

	.  reduce 35


state 68
	expr : literal .  (50)

	.  reduce 50


state 69
	expr : binop .  (52)

	.  reduce 52


state 70
	expr : unop .  (53)

	.  reduce 53


state 71
	stmt_body : READ lvalue .  (34)

	.  reduce 34


state 72
	stmt : IF expr . THEN stmts FI  (30)
	stmt : IF expr . THEN stmts ELSE stmts FI  (31)
	binop : expr . PLUS expr  (57)
	binop : expr . MINUS expr  (58)
	binop : expr . MUL expr  (59)
	binop : expr . DIV expr  (60)
	binop : expr . AND expr  (61)
	binop : expr . OR expr  (62)
	binop : expr . EQ expr  (63)
	binop : expr . NEQ expr  (64)
	binop : expr . LT expr  (65)
	binop : expr . LEQ expr  (66)
	binop : expr . GT expr  (67)
	binop : expr . GEQ expr  (68)

	THEN  shift 98
	OR  shift 86
	AND  shift 87
	EQ  shift 88
	NEQ  shift 89
	LT  shift 90
	LEQ  shift 91
	GT  shift 92
	GEQ  shift 93
	PLUS  shift 94
	MINUS  shift 95
	MUL  shift 96
	DIV  shift 97
	.  error


state 73
	stmt : WHILE expr . DO stmts OD  (32)
	binop : expr . PLUS expr  (57)
	binop : expr . MINUS expr  (58)
	binop : expr . MUL expr  (59)
	binop : expr . DIV expr  (60)
	binop : expr . AND expr  (61)
	binop : expr . OR expr  (62)
	binop : expr . EQ expr  (63)
	binop : expr . NEQ expr  (64)
	binop : expr . LT expr  (65)
	binop : expr . LEQ expr  (66)
	binop : expr . GT expr  (67)
	binop : expr . GEQ expr  (68)

	DO  shift 99
	OR  shift 86
	AND  shift 87
	EQ  shift 88
	NEQ  shift 89
	LT  shift 90
	LEQ  shift 91
	GT  shift 92
	GEQ  shift 93
	PLUS  shift 94
	MINUS  shift 95
	MUL  shift 96
	DIV  shift 97
	.  error


state 74
	decl : typespec IDENT . SEMICOLON  (26)

	SEMICOLON  shift 100
	.  error


state 75
	proc_call : IDENT . LPAREN exprs RPAREN  (37)
	lvalue : IDENT . DOT lvalue  (48)
	lvalue : IDENT .  (49)

	DOT  shift 56
	LPAREN  shift 57
	ASSIGN  reduce 49


state 76
	stmts : stmts stmt .  (27)

	.  reduce 27


state 77
	stmt : stmt_body SEMICOLON .  (29)

	.  reduce 29


state 78
	stmt_body : lvalue ASSIGN . rvalue  (36)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	LBRACE  shift 101
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 102
	lvalue  goto 66
	rvalue  goto 103
	struct_init  goto 104
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 79
	proc : PROC IDENT LPAREN proc_params RPAREN proc_body END .  (17)

	.  reduce 17


state 80
	lvalue : IDENT DOT lvalue .  (48)

	.  reduce 48


state 81
	exprs : expr .  (39)
	binop : expr . PLUS expr  (57)
	binop : expr . MINUS expr  (58)
	binop : expr . MUL expr  (59)
	binop : expr . DIV expr  (60)
	binop : expr . AND expr  (61)
	binop : expr . OR expr  (62)
	binop : expr . EQ expr  (63)
	binop : expr . NEQ expr  (64)
	binop : expr . LT expr  (65)
	binop : expr . LEQ expr  (66)
	binop : expr . GT expr  (67)
	binop : expr . GEQ expr  (68)

	OR  shift 86
	AND  shift 87
	EQ  shift 88
	NEQ  shift 89
	LT  shift 90
	LEQ  shift 91
	GT  shift 92
	GEQ  shift 93
	PLUS  shift 94
	MINUS  shift 95
	MUL  shift 96
	DIV  shift 97
	COMMA  reduce 39
	RPAREN  reduce 39


state 82
	proc_call : IDENT LPAREN exprs . RPAREN  (37)
	exprs : exprs . COMMA expr  (38)

	COMMA  shift 105
	RPAREN  shift 106
	.  error


state 83
	expr : LPAREN expr . RPAREN  (54)
	binop : expr . PLUS expr  (57)
	binop : expr . MINUS expr  (58)
	binop : expr . MUL expr  (59)
	binop : expr . DIV expr  (60)
	binop : expr . AND expr  (61)
	binop : expr . OR expr  (62)
	binop : expr . EQ expr  (63)
	binop : expr . NEQ expr  (64)
	binop : expr . LT expr  (65)
	binop : expr . LEQ expr  (66)
	binop : expr . GT expr  (67)
	binop : expr . GEQ expr  (68)

	RPAREN  shift 107
	OR  shift 86
	AND  shift 87
	EQ  shift 88
	NEQ  shift 89
	LT  shift 90
	LEQ  shift 91
	GT  shift 92
	GEQ  shift 93
	PLUS  shift 94
	MINUS  shift 95
	MUL  shift 96
	DIV  shift 97
	.  error


state 84
	binop : expr . PLUS expr  (57)
	binop : expr . MINUS expr  (58)
	binop : expr . MUL expr  (59)
	binop : expr . DIV expr  (60)
	binop : expr . AND expr  (61)
	binop : expr . OR expr  (62)
	binop : expr . EQ expr  (63)
	binop : expr . NEQ expr  (64)
	binop : expr . LT expr  (65)
	binop : expr . LEQ expr  (66)
	binop : expr . GT expr  (67)
	binop : expr . GEQ expr  (68)
	unop : NOT expr .  (70)

	EQ  shift 88
	NEQ  shift 89
	LT  shift 90
	LEQ  shift 91
	GT  shift 92
	GEQ  shift 93
	PLUS  shift 94
	MINUS  shift 95
	MUL  shift 96
	DIV  shift 97
	THEN  reduce 70
	DO  reduce 70
	COMMA  reduce 70
	RPAREN  reduce 70
	RBRACE  reduce 70
	OR  reduce 70
	AND  reduce 70
	SEMICOLON  reduce 70


state 85
	binop : expr . PLUS expr  (57)
	binop : expr . MINUS expr  (58)
	binop : expr . MUL expr  (59)
	binop : expr . DIV expr  (60)
	binop : expr . AND expr  (61)
	binop : expr . OR expr  (62)
	binop : expr . EQ expr  (63)
	binop : expr . NEQ expr  (64)
	binop : expr . LT expr  (65)
	binop : expr . LEQ expr  (66)
	binop : expr . GT expr  (67)
	binop : expr . GEQ expr  (68)
	unop : MINUS expr .  (69)

	.  reduce 69


state 86
	binop : expr OR . expr  (62)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 108
	lvalue  goto 66
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 87
	binop : expr AND . expr  (61)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 109
	lvalue  goto 66
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 88
	binop : expr EQ . expr  (63)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 110
	lvalue  goto 66
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 89
	binop : expr NEQ . expr  (64)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 111
	lvalue  goto 66
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 90
	binop : expr LT . expr  (65)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 112
	lvalue  goto 66
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 91
	binop : expr LEQ . expr  (66)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 113
	lvalue  goto 66
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 92
	binop : expr GT . expr  (67)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 114
	lvalue  goto 66
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 93
	binop : expr GEQ . expr  (68)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 115
	lvalue  goto 66
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 94
	binop : expr PLUS . expr  (57)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 116
	lvalue  goto 66
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 95
	binop : expr MINUS . expr  (58)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 117
	lvalue  goto 66
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 96
	binop : expr MUL . expr  (59)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 118
	lvalue  goto 66
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 97
	binop : expr DIV . expr  (60)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 119
	lvalue  goto 66
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 98
	stmt : IF expr THEN . stmts FI  (30)
	stmt : IF expr THEN . stmts ELSE stmts FI  (31)

	IDENT  shift 75
	WRITE  shift 42
	READ  shift 43
	IF  shift 44
	WHILE  shift 45
	.  error

	stmts  goto 120
	stmt  goto 49
	stmt_body  goto 50
	proc_call  goto 51
	lvalue  goto 52


state 99
	stmt : WHILE expr DO . stmts OD  (32)

	IDENT  shift 75
	WRITE  shift 42
	READ  shift 43
	IF  shift 44
	WHILE  shift 45
	.  error

	stmts  goto 121
	stmt  goto 49
	stmt_body  goto 50
	proc_call  goto 51
	lvalue  goto 52


state 100
	decl : typespec IDENT SEMICOLON .  (26)

	.  reduce 26


state 101
	struct_init : LBRACE . struct_assigns RBRACE  (43)
	struct_assigns : .  (46)

	IDENT  shift 122
	COMMA  reduce 46
	RBRACE  reduce 46

	struct_assigns  goto 123
	struct_assign  goto 124


state 102
	rvalue : expr .  (41)
	binop : expr . PLUS expr  (57)
	binop : expr . MINUS expr  (58)
	binop : expr . MUL expr  (59)
	binop : expr . DIV expr  (60)
	binop : expr . AND expr  (61)
	binop : expr . OR expr  (62)
	binop : expr . EQ expr  (63)
	binop : expr . NEQ expr  (64)
	binop : expr . LT expr  (65)
	binop : expr . LEQ expr  (66)
	binop : expr . GT expr  (67)
	binop : expr . GEQ expr  (68)

	OR  shift 86
	AND  shift 87
	EQ  shift 88
	NEQ  shift 89
	LT  shift 90
	LEQ  shift 91
	GT  shift 92
	GEQ  shift 93
	PLUS  shift 94
	MINUS  shift 95
	MUL  shift 96
	DIV  shift 97
	COMMA  reduce 41
	RBRACE  reduce 41
	SEMICOLON  reduce 41


state 103
	stmt_body : lvalue ASSIGN rvalue .  (36)

	.  reduce 36


state 104
	rvalue : struct_init .  (42)

	.  reduce 42


state 105
	exprs : exprs COMMA . expr  (38)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 125
	lvalue  goto 66
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 106
	proc_call : IDENT LPAREN exprs RPAREN .  (37)

	.  reduce 37


state 107
	expr : LPAREN expr RPAREN .  (54)

	.  reduce 54


state 108
	binop : expr . PLUS expr  (57)
	binop : expr . MINUS expr  (58)
	binop : expr . MUL expr  (59)
	binop : expr . DIV expr  (60)
	binop : expr . AND expr  (61)
	binop : expr . OR expr  (62)
	binop : expr OR expr .  (62)
	binop : expr . EQ expr  (63)
	binop : expr . NEQ expr  (64)
	binop : expr . LT expr  (65)
	binop : expr . LEQ expr  (66)
	binop : expr . GT expr  (67)
	binop : expr . GEQ expr  (68)

	AND  shift 87
	EQ  shift 88
	NEQ  shift 89
	LT  shift 90
	LEQ  shift 91
	GT  shift 92
	GEQ  shift 93
	PLUS  shift 94
	MINUS  shift 95
	MUL  shift 96
	DIV  shift 97
	THEN  reduce 62
	DO  reduce 62
	COMMA  reduce 62
	RPAREN  reduce 62
	RBRACE  reduce 62
	OR  reduce 62
	SEMICOLON  reduce 62


state 109
	binop : expr . PLUS expr  (57)
	binop : expr . MINUS expr  (58)
	binop : expr . MUL expr  (59)
	binop : expr . DIV expr  (60)
	binop : expr . AND expr  (61)
	binop : expr AND expr .  (61)
	binop : expr . OR expr  (62)
	binop : expr . EQ expr  (63)
	binop : expr . NEQ expr  (64)
	binop : expr . LT expr  (65)
	binop : expr . LEQ expr  (66)
	binop : expr . GT expr  (67)
	binop : expr . GEQ expr  (68)

	EQ  shift 88
	NEQ  shift 89
	LT  shift 90
	LEQ  shift 91
	GT  shift 92
	GEQ  shift 93
	PLUS  shift 94
	MINUS  shift 95
	MUL  shift 96
	DIV  shift 97
	THEN  reduce 61
	DO  reduce 61
	COMMA  reduce 61
	RPAREN  reduce 61
	RBRACE  reduce 61
	OR  reduce 61
	AND  reduce 61
	SEMICOLON  reduce 61


state 110
	binop : expr . PLUS expr  (57)
	binop : expr . MINUS expr  (58)
	binop : expr . MUL expr  (59)
	binop : expr . DIV expr  (60)
	binop : expr . AND expr  (61)
	binop : expr . OR expr  (62)
	binop : expr . EQ expr  (63)
	binop : expr EQ expr .  (63)
	binop : expr . NEQ expr  (64)
	binop : expr . LT expr  (65)
	binop : expr . LEQ expr  (66)
	binop : expr . GT expr  (67)
	binop : expr . GEQ expr  (68)

	PLUS  shift 94
	MINUS  shift 95
	MUL  shift 96
	DIV  shift 97
	THEN  reduce 63
	DO  reduce 63
	COMMA  reduce 63
	RPAREN  reduce 63
	RBRACE  reduce 63
	OR  reduce 63
	AND  reduce 63
	SEMICOLON  reduce 63


state 111
	binop : expr . PLUS expr  (57)
	binop : expr . MINUS expr  (58)
	binop : expr . MUL expr  (59)
	binop : expr . DIV expr  (60)
	binop : expr . AND expr  (61)
	binop : expr . OR expr  (62)
	binop : expr . EQ expr  (63)
	binop : expr . NEQ expr  (64)
	binop : expr NEQ expr .  (64)
	binop : expr . LT expr  (65)
	binop : expr . LEQ expr  (66)
	binop : expr . GT expr  (67)
	binop : expr . GEQ expr  (68)

	PLUS  shift 94
	MINUS  shift 95
	MUL  shift 96
	DIV  shift 97
	THEN  reduce 64
	DO  reduce 64
	COMMA  reduce 64
	RPAREN  reduce 64
	RBRACE  reduce 64
	OR  reduce 64
	AND  reduce 64
	SEMICOLON  reduce 64


state 112
	binop : expr . PLUS expr  (57)
	binop : expr . MINUS expr  (58)
	binop : expr . MUL expr  (59)
	binop : expr . DIV expr  (60)
	binop : expr . AND expr  (61)
	binop : expr . OR expr  (62)
	binop : expr . EQ expr  (63)
	binop : expr . NEQ expr  (64)
	binop : expr . LT expr  (65)
	binop : expr LT expr .  (65)
	binop : expr . LEQ expr  (66)
	binop : expr . GT expr  (67)
	binop : expr . GEQ expr  (68)

	PLUS  shift 94
	MINUS  shift 95
	MUL  shift 96
	DIV  shift 97
	THEN  reduce 65
	DO  reduce 65
	COMMA  reduce 65
	RPAREN  reduce 65
	RBRACE  reduce 65
	OR  reduce 65
	AND  reduce 65
	SEMICOLON  reduce 65


state 113
	binop : expr . PLUS expr  (57)
	binop : expr . MINUS expr  (58)
	binop : expr . MUL expr  (59)
	binop : expr . DIV expr  (60)
	binop : expr . AND expr  (61)
	binop : expr . OR expr  (62)
	binop : expr . EQ expr  (63)
	binop : expr . NEQ expr  (64)
	binop : expr . LT expr  (65)
	binop : expr . LEQ expr  (66)
	binop : expr LEQ expr .  (66)
	binop : expr . GT expr  (67)
	binop : expr . GEQ expr  (68)

	PLUS  shift 94
	MINUS  shift 95
	MUL  shift 96
	DIV  shift 97
	THEN  reduce 66
	DO  reduce 66
	COMMA  reduce 66
	RPAREN  reduce 66
	RBRACE  reduce 66
	OR  reduce 66
	AND  reduce 66
	SEMICOLON  reduce 66


state 114
	binop : expr . PLUS expr  (57)
	binop : expr . MINUS expr  (58)
	binop : expr . MUL expr  (59)
	binop : expr . DIV expr  (60)
	binop : expr . AND expr  (61)
	binop : expr . OR expr  (62)
	binop : expr . EQ expr  (63)
	binop : expr . NEQ expr  (64)
	binop : expr . LT expr  (65)
	binop : expr . LEQ expr  (66)
	binop : expr . GT expr  (67)
	binop : expr GT expr .  (67)
	binop : expr . GEQ expr  (68)

	PLUS  shift 94
	MINUS  shift 95
	MUL  shift 96
	DIV  shift 97
	THEN  reduce 67
	DO  reduce 67
	COMMA  reduce 67
	RPAREN  reduce 67
	RBRACE  reduce 67
	OR  reduce 67
	AND  reduce 67
	SEMICOLON  reduce 67


state 115
	binop : expr . PLUS expr  (57)
	binop : expr . MINUS expr  (58)
	binop : expr . MUL expr  (59)
	binop : expr . DIV expr  (60)
	binop : expr . AND expr  (61)
	binop : expr . OR expr  (62)
	binop : expr . EQ expr  (63)
	binop : expr . NEQ expr  (64)
	binop : expr . LT expr  (65)
	binop : expr . LEQ expr  (66)
	binop : expr . GT expr  (67)
	binop : expr . GEQ expr  (68)
	binop : expr GEQ expr .  (68)

	PLUS  shift 94
	MINUS  shift 95
	MUL  shift 96
	DIV  shift 97
	THEN  reduce 68
	DO  reduce 68
	COMMA  reduce 68
	RPAREN  reduce 68
	RBRACE  reduce 68
	OR  reduce 68
	AND  reduce 68
	SEMICOLON  reduce 68


state 116
	binop : expr . PLUS expr  (57)
	binop : expr PLUS expr .  (57)
	binop : expr . MINUS expr  (58)
	binop : expr . MUL expr  (59)
	binop : expr . DIV expr  (60)
	binop : expr . AND expr  (61)
	binop : expr . OR expr  (62)
	binop : expr . EQ expr  (63)
	binop : expr . NEQ expr  (64)
	binop : expr . LT expr  (65)
	binop : expr . LEQ expr  (66)
	binop : expr . GT expr  (67)
	binop : expr . GEQ expr  (68)

	MUL  shift 96
	DIV  shift 97
	THEN  reduce 57
	DO  reduce 57
	COMMA  reduce 57
	RPAREN  reduce 57
	RBRACE  reduce 57
	OR  reduce 57
	AND  reduce 57
	EQ  reduce 57
	NEQ  reduce 57
	LT  reduce 57
	LEQ  reduce 57
	GT  reduce 57
	GEQ  reduce 57
	PLUS  reduce 57
	MINUS  reduce 57
	SEMICOLON  reduce 57


state 117
	binop : expr . PLUS expr  (57)
	binop : expr . MINUS expr  (58)
	binop : expr MINUS expr .  (58)
	binop : expr . MUL expr  (59)
	binop : expr . DIV expr  (60)
	binop : expr . AND expr  (61)
	binop : expr . OR expr  (62)
	binop : expr . EQ expr  (63)
	binop : expr . NEQ expr  (64)
	binop : expr . LT expr  (65)
	binop : expr . LEQ expr  (66)
	binop : expr . GT expr  (67)
	binop : expr . GEQ expr  (68)

	MUL  shift 96
	DIV  shift 97
	THEN  reduce 58
	DO  reduce 58
	COMMA  reduce 58
	RPAREN  reduce 58
	RBRACE  reduce 58
	OR  reduce 58
	AND  reduce 58
	EQ  reduce 58
	NEQ  reduce 58
	LT  reduce 58
	LEQ  reduce 58
	GT  reduce 58
	GEQ  reduce 58
	PLUS  reduce 58
	MINUS  reduce 58
	SEMICOLON  reduce 58


state 118
	binop : expr . PLUS expr  (57)
	binop : expr . MINUS expr  (58)
	binop : expr . MUL expr  (59)
	binop : expr MUL expr .  (59)
	binop : expr . DIV expr  (60)
	binop : expr . AND expr  (61)
	binop : expr . OR expr  (62)
	binop : expr . EQ expr  (63)
	binop : expr . NEQ expr  (64)
	binop : expr . LT expr  (65)
	binop : expr . LEQ expr  (66)
	binop : expr . GT expr  (67)
	binop : expr . GEQ expr  (68)

	.  reduce 59


state 119
	binop : expr . PLUS expr  (57)
	binop : expr . MINUS expr  (58)
	binop : expr . MUL expr  (59)
	binop : expr . DIV expr  (60)
	binop : expr DIV expr .  (60)
	binop : expr . AND expr  (61)
	binop : expr . OR expr  (62)
	binop : expr . EQ expr  (63)
	binop : expr . NEQ expr  (64)
	binop : expr . LT expr  (65)
	binop : expr . LEQ expr  (66)
	binop : expr . GT expr  (67)
	binop : expr . GEQ expr  (68)

	.  reduce 60


state 120
	stmts : stmts . stmt  (27)
	stmt : IF expr THEN stmts . FI  (30)
	stmt : IF expr THEN stmts . ELSE stmts FI  (31)

	IDENT  shift 75
	WRITE  shift 42
	READ  shift 43
	IF  shift 44
	ELSE  shift 126
	FI  shift 127
	WHILE  shift 45
	.  error

	stmt  goto 76
	stmt_body  goto 50
	proc_call  goto 51
	lvalue  goto 52


state 121
	stmts : stmts . stmt  (27)
	stmt : WHILE expr DO stmts . OD  (32)

	IDENT  shift 75
	WRITE  shift 42
	READ  shift 43
	IF  shift 44
	WHILE  shift 45
	OD  shift 128
	.  error

	stmt  goto 76
	stmt_body  goto 50
	proc_call  goto 51
	lvalue  goto 52


state 122
	struct_assign : IDENT . EQ rvalue  (47)

	EQ  shift 129
	.  error


state 123
	struct_init : LBRACE struct_assigns . RBRACE  (43)
	struct_assigns : struct_assigns . COMMA struct_assign  (44)

	COMMA  shift 130
	RBRACE  shift 131
	.  error


state 124
	struct_assigns : struct_assign .  (45)

	.  reduce 45


state 125
	exprs : exprs COMMA expr .  (38)
	binop : expr . PLUS expr  (57)
	binop : expr . MINUS expr  (58)
	binop : expr . MUL expr  (59)
	binop : expr . DIV expr  (60)
	binop : expr . AND expr  (61)
	binop : expr . OR expr  (62)
	binop : expr . EQ expr  (63)
	binop : expr . NEQ expr  (64)
	binop : expr . LT expr  (65)
	binop : expr . LEQ expr  (66)
	binop : expr . GT expr  (67)
	binop : expr . GEQ expr  (68)

	OR  shift 86
	AND  shift 87
	EQ  shift 88
	NEQ  shift 89
	LT  shift 90
	LEQ  shift 91
	GT  shift 92
	GEQ  shift 93
	PLUS  shift 94
	MINUS  shift 95
	MUL  shift 96
	DIV  shift 97
	COMMA  reduce 38
	RPAREN  reduce 38


state 126
	stmt : IF expr THEN stmts ELSE . stmts FI  (31)

	IDENT  shift 75
	WRITE  shift 42
	READ  shift 43
	IF  shift 44
	WHILE  shift 45
	.  error

	stmts  goto 132
	stmt  goto 49
	stmt_body  goto 50
	proc_call  goto 51
	lvalue  goto 52


state 127
	stmt : IF expr THEN stmts FI .  (30)

	.  reduce 30


state 128
	stmt : WHILE expr DO stmts OD .  (32)

	.  reduce 32


state 129
	struct_assign : IDENT EQ . rvalue  (47)

	BOOL_CONST  shift 58
	INT_CONST  shift 59
	IDENT  shift 61
	LPAREN  shift 62
	LBRACE  shift 101
	NOT  shift 63
	MINUS  shift 64
	.  error

	expr  goto 102
	lvalue  goto 66
	rvalue  goto 133
	struct_init  goto 104
	literal  goto 68
	binop  goto 69
	unop  goto 70


state 130
	struct_assigns : struct_assigns COMMA . struct_assign  (44)

	IDENT  shift 122
	.  error

	struct_assign  goto 134


state 131
	struct_init : LBRACE struct_assigns RBRACE .  (43)

	.  reduce 43


state 132
	stmts : stmts . stmt  (27)
	stmt : IF expr THEN stmts ELSE stmts . FI  (31)

	IDENT  shift 75
	WRITE  shift 42
	READ  shift 43
	IF  shift 44
	FI  shift 135
	WHILE  shift 45
	.  error

	stmt  goto 76
	stmt_body  goto 50
	proc_call  goto 51
	lvalue  goto 52


state 133
	struct_assign : IDENT EQ rvalue .  (47)

	.  reduce 47


state 134
	struct_assigns : struct_assigns COMMA struct_assign .  (44)

	.  reduce 44


state 135
	stmt : IF expr THEN stmts ELSE stmts FI .  (31)

	.  reduce 31


48 terminals, 33 nonterminals
74 grammar rules, 136 states
============================================
src/bean.ml
16:38:20_Friday_20_May_2016
============================================
(* ============================================== *)
(* Main Module of the Bean Compiler               *)
(* --------------------------------               *)
(* This module orchestrates the Bean compiler.    *)
(* It reads in a file or from stdin, and          *)
(* and depending on the flag, either compiles or  *)
(* pretty prints a Bean program                   *)
(* ============================================== *)

open Format
module P = Bean_parse

(* Argument parsing code *)
type compiler_mode = PrettyPrint | Compile

let infile_name  = ref None    (* Name of the (.bean) file read in      *)
let mode         = ref Compile (* PrettyPrint or (default) Compile mode *)
let outfile_name = ref None    (* Name of the file to pipe to           *)
let debug        = ref false   (* Debug flag                            *)

(* --------------------------------------------- *)
(*  Specification for command-line options       *)
(* --------------------------------------------- *)
let (speclist:(Arg.key * Arg.spec * Arg.doc) list) =
  [
    ("-p", Arg.Unit (fun () -> mode := PrettyPrint),
     " Run the compiler in pretty-printer mode");

    ("-o", Arg.String (fun str -> outfile_name := Some str),
     " Specify the output file for bean to compile to");

    ("--debug", Arg.Unit (fun () -> debug := true),
     " Run the compiler in debug mode, so it just prints to the screen")
  ]

(* --------------------------------------------- *)
(*  Lexer/Parser error tracking functions        *)
(* --------------------------------------------- *)

(* MAIN FUNCTION *)
let main () =
  (* Parse the command-line arguments *)
  Arg.parse speclist
      (begin fun fname -> infile_name := Some fname end)
      "bean [-p] [bean source]" ;

  (* select the input file *)
  let infile =
    match !infile_name with
    | None       -> stdin
    | Some fname -> open_in fname in

  (* Initialize lexing buffer *)
  let lexbuf   = Lexing.from_channel infile in

  let filename =
    match !infile_name with
    | None       -> "\"stdin\""
    | Some fname -> "\"" ^ fname ^ "\""
  in

  (* Assume bean doesn't link -- so the file being lexed
   * is always the one the compiler was called on...     *)
  Bean_lex.set_lex_file filename lexbuf;
  (* Call the parser *)
  try
    (* Parsing happens here *)
    let prog   = Bean_parse.program Bean_lex.token lexbuf in
    let symtbl = Bean_symtbl.build_symtbl_checked prog in
    match !mode with
    | PrettyPrint ->
        Bean_pprint.print_program Format.std_formatter prog
    | Compile ->
        let ir_prog = Bean_intermediate_code.gen_code_checked symtbl prog in
        let oz_prog = Bean_oz.generate_oz_code ir_prog in
        (* Determine where to pipe output *)
        let outfile =
          match !outfile_name with
          | Some filename -> open_out filename
          | None          -> stdout
        in
        try
          Printf.fprintf outfile "%s" oz_prog;
          if   not !debug
          then close_out outfile
          else ()
        with e ->
          close_out_noerr outfile;
          raise e
  with
  (* Error catching here*)
  | Bean_lex.Lex_error msg ->
      let (fname, ln, col) = Bean_lex.get_lex_pos lexbuf in
      Printf.fprintf stderr
        "Lexer error: %s at line %i, column %i in file %s\n" msg ln col fname;
      exit 1
  | Parsing.Parse_error ->
      let (fname, ln, col) = Bean_lex.get_lex_pos lexbuf in
      Printf.fprintf stderr
        "%s at line %i, column %i in file %s\n" "Parse error" ln col fname;
      exit 1
  | Bean_symtbl.Definition_error (msg, pos) ->
      let (file, (st_ln, st_col), (end_ln, end_col)) =
        Bean_ast.get_pos_info pos
      in
      Printf.fprintf stderr
        "%s: From line %i, column %i to line %i, column %i in file %s\n"
        msg st_ln st_col end_ln end_col file;
      exit 1
  | Bean_semantic.Semantic_error (msg, pos) ->
      let (file, (st_ln, st_col), (end_ln, end_col)) =
        Bean_ast.get_pos_info pos
      in
      Printf.fprintf stderr
        "%s: From line %i, column %i to line %i, column %i in file %s\n"
        msg st_ln st_col end_ln end_col file;
      exit 1
  | Bean_semantic.No_main_proc ->
      Printf.fprintf stderr "No main function defined in %s\n" filename;
      exit 1

let _ = main ()
============================================
src/bean_symtbl.mli
16:38:20_Friday_20_May_2016
============================================
(* Bean Symbol Table *)

(* ========================================================================== *)
(* ======================= DATA STRUCTURE DEFINITIONS ======================= *)
(* ========================================================================== *)

(* Store identities using whatever format the Bean_ast is using *)
type ident = Bean_ast.ident

(* The parser records positions at both the start and end of the
 * symbol. We can use this to generate very descriptive error messages *)
type pos = (Lexing.position * Lexing.position)

(* A type specification may be either:
 *   - a vanilla bean type
 *   - a more chocolatey user-defined type
 *   - a rather nutty compound struct-like type *)
type typespec =
  | TSBeantype    of Bean_ast.beantype
  | TSDefinedtype of typedef
  | TSFieldStruct of field_struct

(* A field type declaration is composed of a position
 * and a type specification                               *)
and field_decl = {
  field_pos:  pos;
  field_type: typespec;
}

(* A field struct (C-struct-like compound type) becomes a
 * lookup table for fields, each having an
 * identifier and a type declaration                       *)
and field_struct = (ident, field_decl) Hashtbl.t

(* A typedef, composed of:
 *   - a type
 *   - a position          *)
and typedef = (typespec * pos)

type var_scope =
  | SDecl
  | SParamVal
  | SParamRef

type type_symbol =
  | STBeantype    of  Bean_ast.beantype
  | STFieldStruct of (ident, field_symbol) Hashtbl.t

and field_symbol = (type_symbol * int option ref)

type var_symbol = (type_symbol * var_scope * int option ref * pos)

(* Procedure symbol table, composed of:
 *   - a parameter hashtable
 *   - a declaration hashtable
 *   - a position (for error messages)   *)
type proc =
  { (* Params must be a list, since Hashtbl doesn't preserve order *)
    proc_params:   Bean_ast.ident list;
    proc_sym_tbl:  (ident, var_symbol) Hashtbl.t;
    proc_label:    string option ref;
    proc_pos:      pos;
  }

(* Symbol (lookup) table, composed of:
 *   - a typedef hashtable
 *   - a procedure hashtable            *)
type symtbl =
  { sym_tds:   (ident, typedef) Hashtbl.t;
    sym_procs: (ident, proc) Hashtbl.t;
  }

(* Symbol table convenience type alias,
 * allows other modules to use `Bean_symtbl.t` *)
type t = symtbl

(* ========================================================================== *)
(* ========================= EXCEPTION DEFINTIIONS ========================== *)
(* ========================================================================== *)

(* Exception if the user has tried to set a type
 * they have not defined                         *)

exception Definition_error     of string * Bean_ast.pos

(* two typedefs share the same name             *)
exception Duplicate_type       of string * Bean_ast.pos
(* two procs share the same name                *)
exception Duplicate_proc       of string * Bean_ast.pos
(* two parameters share the same name           *)
exception Duplicate_param      of string * Bean_ast.pos
(* variable is declared twice in the same scope *)
exception Duplicate_decl       of string * Bean_ast.pos
(* two fields in a struct share the same name   *)
exception Duplicate_field      of string * Bean_ast.pos

exception Undefined_variable   of string * Bean_ast.pos
(* call made to a proc that doesn't exist       *)
exception Undefined_proc       of string * Bean_ast.pos
(* struct does not have a field of this name    *)
exception Undefined_field      of string * Bean_ast.pos
exception Undefined_type       of string * Bean_ast.pos

(* ========================================================================== *)
(* ========================== INTERFACE FUNCTIONS =========================== *)
(* ========================================================================== *)

val get_field_sym: (Bean_ast.ident, field_symbol) Hashtbl.t -> Bean_ast.lvalue -> field_symbol
val get_var_sym:         symtbl -> Bean_ast.ident -> Bean_ast.ident  -> var_symbol
val get_lval_sym:        symtbl -> Bean_ast.ident -> Bean_ast.lvalue -> field_symbol
val get_id_type:         symtbl -> Bean_ast.ident -> Bean_ast.ident  -> type_symbol
val get_lval_type:       symtbl -> Bean_ast.ident -> Bean_ast.lvalue -> type_symbol
val set_id_slot:         symtbl -> Bean_ast.ident -> Bean_ast.ident  -> int -> int
val get_lid_slot_num:    symtbl -> Bean_ast.ident -> Bean_ast.ident  -> int
val get_lfield_slot_num: symtbl -> Bean_ast.ident -> (Bean_ast.lvalue * Bean_ast.ident) -> int
val set_proc_label:      symtbl -> Bean_ast.ident -> string -> unit
val get_proc_label:      symtbl -> Bean_ast.ident -> Bean_ast.pos    -> string
val get_param_list:      symtbl -> Bean_ast.ident -> Bean_ast.ident list

val get_lval_scope:      symtbl -> Bean_ast.ident -> Bean_ast.lvalue ->
  Bean_ast.pos -> var_scope
val get_proc_var_scope:  symtbl -> Bean_ast.ident -> Bean_ast.ident -> Bean_ast.pos -> var_scope
val get_proc_pos: symtbl -> Bean_ast.ident -> Bean_ast.pos

(* ========================================================================== *)
(* ========================= CONSTRUCTOR FUNCTIONS ========================== *)
(* ========================================================================== *)

val build_symtbl_checked: Bean_ast.t -> symtbl
============================================
src/bean_symtbl.ml
16:38:20_Friday_20_May_2016
============================================
(* Bean Symbol Table *)

module AST = Bean_ast
module P   = Bean_pprint


(* ========================================================================== *)
(* ======================= DATA STRUCTURE DEFINITIONS ======================= *)
(* ========================================================================== *)

(* Store identities using whatever format the AST is using *)
type ident = AST.ident

(* The parser records positions at both the start and end of the
 * symbol. We can use this to generate very descriptive error messages *)
type pos = (Lexing.position * Lexing.position)

(* A type specification may be either:
 *   - a vanilla bean type
 *   - a more chocolatey user-defined type
 *   - a rather nutty compound struct-like type *)
type typespec =
  | TSBeantype    of AST.beantype
  | TSDefinedtype of typedef
  | TSFieldStruct of field_struct

(* A field type declaration is composed of a position
 * and a type specification                               *)
and field_decl = {
  field_pos:  pos;
  field_type: typespec;
}

(* A field struct (C-struct-like compound type) becomes a
 * lookup table for fields, each having an
 * identifier and a type declaration                       *)
and field_struct = (ident, field_decl) Hashtbl.t

(* A typedef, composed of:
 *   - a type
 *   - a position          *)
and typedef = (typespec * pos)

type var_scope =
  | SDecl
  | SParamVal
  | SParamRef

type type_symbol =
  | STBeantype    of  AST.beantype
  | STFieldStruct of (ident, field_symbol) Hashtbl.t

and field_symbol = (type_symbol * int option ref)

type var_symbol = (type_symbol * var_scope * int option ref * pos)

(* Procedure symbol table, composed of:
 *   - a parameter hashtable
 *   - a declaration hashtable
 *   - a position (for error messages)   *)
type proc =
  { (* Params must be a list, since Hashtbl doesn't preserve order *)
    proc_params:   AST.ident list;
    proc_sym_tbl: (ident, var_symbol) Hashtbl.t;
    proc_label:    string option ref;
    proc_pos:      pos;
  }

(* Symbol (lookup) table, composed of:
 *   - a typedef hashtable
 *   - a procedure hashtable            *)
type symtbl =
  { sym_tds:   (ident, typedef) Hashtbl.t;
    sym_procs: (ident, proc) Hashtbl.t;
  }

(* Symbol table convenience type alias,
 * allows other modules to use `Bean_symtbl.t` *)
type t = symtbl

(* ========================================================================== *)
(* ========================= EXCEPTION DEFINTIIONS ========================== *)
(* ========================================================================== *)

(* Exception if the user has tried to set a type
 * they have not defined                         *)

exception Definition_error     of string * AST.pos

(* two typedefs share the same name             *)
exception Duplicate_type       of string * AST.pos
(* two procs share the same name                *)
exception Duplicate_proc       of string * AST.pos
(* two parameters share the same name           *)
exception Duplicate_param      of string * AST.pos
(* variable is declared twice in the same scope *)
exception Duplicate_decl       of string * AST.pos
(* two fields in a struct share the same name   *)
exception Duplicate_field      of string * AST.pos

exception Undefined_type       of string * AST.pos
exception Undefined_variable   of string * AST.pos
exception Undefined_proc       of string * AST.pos
(* struct does not have a field of this name    *)
exception Undefined_field      of string * AST.pos

exception No_field
exception Slot_not_allocated (* no slot to store the value in                *)
exception No_such_procedure  (* call made to a proc that doesn't exist       *)

(* ========================================================================== *)
(* ========================== INTERFACE FUNCTIONS =========================== *)
(* ========================================================================== *)

let get_proc_pos sym_tbl proc_id =
  let proc = Hashtbl.find sym_tbl.sym_procs proc_id in
  proc.proc_pos

let rec get_field_sym fieldtbl lvalue =
  match lvalue with
  | AST.LId    (id, _)  -> Hashtbl.find fieldtbl id
  | AST.LField (lv, id) ->
      let pos = AST.get_lval_pos lv in
      let (field_type, _) = Hashtbl.find fieldtbl id in
      match field_type with
      | STBeantype    _        ->
          raise (Undefined_field (P.string_of_lval lvalue, pos))
      | STFieldStruct subfield ->
          get_field_sym subfield lv

let get_var_sym sym_tbl proc_id id =
  let proc = Hashtbl.find sym_tbl.sym_procs proc_id in
  Hashtbl.find proc.proc_sym_tbl id

let get_lval_sym sym_tbl proc_id lval =
  match lval with
  | AST.LId (id, _) ->
      let (type_sym, _, slot, _) = get_var_sym sym_tbl proc_id id in
      (type_sym, slot)
  | AST.LField (lval, id) ->
      let pos                 = AST.get_lval_pos lval in
      let (type_sym, _, _, _) = get_var_sym sym_tbl proc_id id in
      match type_sym with
      | STBeantype    _      -> raise (Undefined_field (id, pos))
      | STFieldStruct fields -> get_field_sym fields lval

(* Get the type of an ordinary variable id
 * when it's not given as an lvalue (like in declarations) *)
let get_id_type sym_tbl proc_id id =
  let proc = Hashtbl.find sym_tbl.sym_procs proc_id in
  let (type_symbol, _, _, _) = Hashtbl.find proc.proc_sym_tbl id in
  type_symbol

(* Get the type symbol of a given lvalue *)
let get_lval_type sym_tbl proc_id lval =
  let pos = AST.get_lval_pos lval in
  match lval with
  | AST.LId    (id, _)    -> get_id_type sym_tbl proc_id id
  | AST.LField (lval, id) ->
      match get_id_type sym_tbl proc_id id with
      | STBeantype    _     -> raise (Undefined_field (id, pos))
      | STFieldStruct field ->
          let (field_type, _) = get_field_sym field lval in
          field_type

let set_id_slot sym_tbl proc_id id slot_num =
  let proc = Hashtbl.find sym_tbl.sym_procs proc_id in
  let (_, _, slot, _) = Hashtbl.find proc.proc_sym_tbl id in
  slot := Some slot_num;
  slot_num+1

(* Retrieve the slot number for an id lvalue in a stack frame *)
let get_lid_slot_num sym_tbl proc_id id =
  let proc = Hashtbl.find sym_tbl.sym_procs proc_id in
  let (_, _, slot, _) = Hashtbl.find proc.proc_sym_tbl id in
  match !slot with
  | None     -> raise Slot_not_allocated
  | Some num -> num

(* Get the slot number allocated to the field given
 * by an lvalue of a variable given by id            *)
let get_lfield_slot_num sym_tbl proc_id (lval, id) =
  let pos = AST.get_lval_pos lval in
  let proc = Hashtbl.find sym_tbl.sym_procs proc_id in
  let (type_sym, _, _, _) = Hashtbl.find proc.proc_sym_tbl id in
  let get_field t_sym field_id =
    match t_sym with
    | STBeantype    _     -> raise (Undefined_field (field_id, pos))
    | STFieldStruct field -> Hashtbl.find field field_id
  in
  let rec get_field_slot field_type lval =
    match lval with
    | AST.LId (id, _) ->
        let (_, slot) = get_field field_type id in
        slot
    | AST.LField (lval, id) ->
        let (subfield_type, _) = get_field field_type id in
        get_field_slot subfield_type lval
  in
  let slot = get_field_slot type_sym lval in
  match !slot with
  | None     -> raise Slot_not_allocated
  | Some num -> num

(* Set the label of a procedure body *)
let set_proc_label sym_tbl proc_id label =
  let proc = Hashtbl.find sym_tbl.sym_procs proc_id in
  proc.proc_label := Some label

let get_proc_label sym_tbl proc_id pos =
  let proc =
    try
      Hashtbl.find sym_tbl.sym_procs proc_id
    with
    | Not_found -> raise (Undefined_proc (proc_id, pos))
  in
  match !(proc.proc_label) with
  | None       -> raise (Undefined_proc (proc_id, pos))
  | Some label -> label

let get_param_list sym_tbl proc_id =
  let proc = Hashtbl.find sym_tbl.sym_procs proc_id in
  proc.proc_params

let get_proc_var_scope sym_tbl proc_id symbol_id pos =
  let proc =
    try
      Hashtbl.find sym_tbl.sym_procs proc_id
    with
    | Not_found -> raise (Undefined_proc (proc_id, pos))
  in
  let proc_syms = proc.proc_sym_tbl in
  let (_, scope, _, _) = Hashtbl.find proc_syms symbol_id in
  scope

let get_lval_scope sym_tbl proc_id lval =
  match lval with
  | AST.LId (id, _) ->    get_proc_var_scope sym_tbl proc_id id
  | AST.LField (_, id) -> get_proc_var_scope sym_tbl proc_id id

(* ========================================================================== *)
(* ========================= CONSTRUCTOR FUNCTIONS ========================== *)
(* ========================================================================== *)

(* Attempt to find a typedef based on the identifier.
 * If no such type is defined, an error is raised     *)
let get_typedef td_tbl (deftype_id, pos) =
  try Hashtbl.find td_tbl deftype_id
  with
  | Not_found ->
      raise (Undefined_type (deftype_id, pos))

(* Add a struct field type to a struct type lookup table *)
let rec add_field_to_tbl td_tbl (id, typespec, pos) tbl =
  let field_decl =
    { field_pos = pos;
      field_type = sym_tbl_t_of_ast_t td_tbl typespec
    }
  in
  if Hashtbl.mem tbl id then
    raise (Duplicate_field (id, pos))
  else
    Hashtbl.add tbl id field_decl;
    tbl

(* Make a type lookup table for the fields from
 * a struct-like typespec                        *)
and
sym_type_of_struct td_tbl fields =
  let struct_tbl = Hashtbl.create 5 in
  List.fold_right (add_field_to_tbl td_tbl) fields struct_tbl

(* Turn an AST type into an O(1) lookup table type,
 * so that typedefs refer to their contents, rather than
 * just being names                                       *)
and
sym_tbl_t_of_ast_t td_tbl typespec =
  match typespec with
  | AST.TSBeantype    bt -> TSBeantype bt
  | AST.TSDefinedtype dt -> TSDefinedtype (get_typedef td_tbl dt)
  | AST.TSFieldStruct fs -> TSFieldStruct (sym_type_of_struct td_tbl fs)

(* Make a symbol instance for a struct variable from a symbolic typespec *)
let rec make_struct_symbol field_struct =
  let field_tbl = Hashtbl.create 5 in
  let add_field id field_decl f_tbl =
    let ft = make_type_symbol field_decl.field_type in
    Hashtbl.add f_tbl id (ft, ref None);
    f_tbl
  in
  STFieldStruct (Hashtbl.fold add_field field_struct field_tbl)

(* Make an instance symbol for a type based on its symbolic type *)
and
make_type_symbol typespec =
  match typespec with
  | TSBeantype bt         -> STBeantype bt
  | TSDefinedtype (ts, _) -> make_type_symbol ts
  | TSFieldStruct fs      -> make_struct_symbol fs

(* Make an instance symbol for a variable *)
let make_var_symbol scope_type typespec pos =
  let type_sym = make_type_symbol typespec in
  (type_sym, scope_type, ref None, pos)

(* Add a single typedef into the lookup table *)
let add_typedef td_tbl (typespec, id, pos) =
  let sym_type = sym_tbl_t_of_ast_t td_tbl typespec in
  if Hashtbl.mem td_tbl id then
    raise (Duplicate_type (id, pos))
  else
    Hashtbl.add td_tbl id (sym_type, pos)

(* Add typedefs into the lookup table *)
let rec add_typedefs td_tbl typedefs =
  match typedefs with
  | td :: tds -> add_typedef td_tbl td; add_typedefs td_tbl tds
  | []        -> ()

let make_decl_symbol td_tbl decl_ast_type decl_pos =
  let decl_type = sym_tbl_t_of_ast_t td_tbl decl_ast_type in
  make_var_symbol SDecl decl_type decl_pos

let add_decl_symbol td_tbl proc_sym_tbl decl =
  let (id, decl_ast_type, decl_pos) = decl in
  let decl_sym = make_decl_symbol td_tbl decl_ast_type decl_pos in
  if Hashtbl.mem proc_sym_tbl id then
    raise (Duplicate_decl (id, decl_pos))
  else
    Hashtbl.add proc_sym_tbl id decl_sym

(* Take a procedure parameter and extract ids as a list key *)
let make_param_symbol td_tbl param_pass typespec param_pos =
  let param_type = sym_tbl_t_of_ast_t td_tbl typespec in
  let param_scope =
    match param_pass with
    | AST.Pval -> SParamVal
    | AST.Pref -> SParamRef
  in
  make_var_symbol param_scope param_type param_pos

(* Add a parameter to a proc's symbol table *)
let add_param_symbol td_tbl proc_sym_tbl param =
  let (param_pass, param_type, id, param_pos) = param in
  let param_sym = make_param_symbol td_tbl param_pass param_type param_pos in
  if Hashtbl.mem proc_sym_tbl id then
    raise (Duplicate_param (id, param_pos))
  else
    Hashtbl.add proc_sym_tbl id param_sym

(* Insert a single procedure into the proc lookup table *)
let add_proc td_tbl p_tbl (id, pparams, (proc_decls, _), proc_pos) () =
  if Hashtbl.mem p_tbl id then
    raise (Duplicate_proc (id, proc_pos))
  else
    let get_param_id (_, _, id, _) ids = id :: ids in
    let proc_params  = List.fold_right get_param_id pparams [] in
    let proc_sym_tbl = Hashtbl.create 10 in
    let proc_label   = ref None in
    let add_param param () = add_param_symbol td_tbl proc_sym_tbl param in
    let add_decl  decl  () = add_decl_symbol td_tbl proc_sym_tbl decl in
    List.fold_right add_param pparams     ();
    List.fold_right add_decl  proc_decls  ();
    let proc = { proc_params  = proc_params;
                 proc_sym_tbl = proc_sym_tbl;
                 proc_label   = proc_label;
                 proc_pos     = proc_pos
               }
    in
    Hashtbl.add p_tbl id proc

(* Insert procedures into a lookup table by ident *)
let rec add_procs td_tbl p_tbl (procs: AST.proc list) =
  List.fold_right (add_proc td_tbl p_tbl) procs ()

(* Symbol table constructor.
 * Takes a complete AST as argument, and constructs a lookup
 * table for all variables in the program for semantic analysis
 * and code generation.                                          *)
let build_symtbl ast =
  let sym_tds   = Hashtbl.create 5  in
  let sym_procs = Hashtbl.create 10 in
  add_typedefs sym_tds ast.AST.typedefs;
  add_procs sym_tds sym_procs ast.AST.procs;
  { sym_tds   = sym_tds;
    sym_procs = sym_procs
  }

let build_symtbl_checked ast =
  try
    build_symtbl ast
  with
  | Duplicate_type (id, pos) ->
      raise (Definition_error ("The type "^id^" is already defined", pos))
  | Undefined_type (id, pos) ->
      raise (Definition_error ("The type "^id^" is not defined", pos))
  | Duplicate_proc (id, pos) ->
      raise (Definition_error ("The procedure "^id^" is already defined", pos))
  | Undefined_proc (id, pos) ->
      raise (Definition_error ("The procedure "^id^" is not defined", pos))
  | Duplicate_param (id, pos) ->
      raise (Definition_error ("The parameter "^id^" is already declared", pos))
  | Duplicate_decl (id, pos) ->
      raise (Definition_error ("The variable "^id^" is already declared", pos))
  | Undefined_variable (id, pos) ->
      raise (Definition_error
        ("The variable "^id^" is not defined anywhere", pos))
  | Duplicate_field (id, pos) ->
      raise (Definition_error ("The field "^id^" is already defined", pos))
  | Undefined_field (id, pos) ->
      raise (Definition_error ("The field "^id^" is not defined", pos))
============================================
src/bean_pprint.ml
16:38:20_Friday_20_May_2016
============================================
(* ==================================================================== *)
(* Pretty Printer for the Bean Language                                 *)
(* ------------------------------------                                 *)
(* This module reads a Bean program as stored in a Bean AST, of type    *)
(* Bean_ast.t, and prints it prettily and correctly, demonstrating the  *)
(* parser and lexer that works to populate the AST                      *)

open Bean_ast
open Format


(* ---- STRING CONVERSION FUNCTIONS FOR AST LEAVES ---- *)

(* Lvalues look like:
 *   - LId -> "x"
 *   - LField -> "x.y.z"   *)
let rec string_of_lval lval =
  match lval with
  | LId     (ident, _)      -> ident
  | LField  (lval, ident)   -> String.concat "." [ident; string_of_lval lval]

(* Binary operator string representations *)
let string_of_binop binop =
  match binop with
  | Op_add  -> "+"
  | Op_sub  -> "-"
  | Op_mul  -> "*"
  | Op_div  -> "/"
  | Op_and  -> "and"
  | Op_or   -> "or"
  | Op_eq   -> "="
  | Op_neq  -> "!="
  | Op_lt   -> "<"
  | Op_leq  -> "<="
  | Op_gt   -> ">"
  | Op_geq  -> ">="

(* String representations of unary operators *)
let string_of_unop unop =
  match unop with
  | Op_minus -> "-"
  | Op_not   -> "not"

(* Places parentheses around a string *)
let parenthesise str =
  String.concat str ["(";")"]

(* Binding precedences of operators in the bean grammar *)
let op_binding expr =
  match expr with
  | Ebinop (_, Op_or,   _, _) -> 1
  | Ebinop (_, Op_and,  _, _) -> 2
  | Eunop  (   Op_not,  _, _) -> 3
  | Ebinop (_, Op_eq,   _, _)
  | Ebinop (_, Op_neq,  _, _)
  | Ebinop (_, Op_lt,   _, _)
  | Ebinop (_, Op_leq,  _, _)
  | Ebinop (_, Op_gt,   _, _)
  | Ebinop (_, Op_geq,  _, _) -> 4
  | Ebinop (_, Op_add,  _, _)
  | Ebinop (_, Op_sub,  _, _) -> 5
  | Ebinop (_, Op_mul,  _, _)
  | Ebinop (_, Op_div,  _, _) -> 6
  | Eunop  ( Op_minus,  _, _) -> 7
  | _                      -> 8 (* all other exprs bind tighter*)


(* String representation of a whole expression *)
let rec string_of_expr expr =
  match expr with
  | Ebool  (ebool, _)                 -> string_of_bool ebool
  | Eint   (eint, _)                  -> string_of_int  eint
  | Elval  (lval, _)                  -> string_of_lval lval
  | Eunop  (unop, subexpr, pos)       -> string_of_unop_expr unop subexpr pos
  | Ebinop (lexpr, binop, rexpr, pos) ->
      string_of_binop_expr binop lexpr rexpr pos

(* String of a unary operator application expression *)
and
string_of_unop_expr unop subexpr pos =
  let concat =
    match unop with
    | Op_minus -> String.concat ""
    | Op_not   -> String.concat " "
  in
  concat [string_of_unop unop;
          paren_unop_string (Eunop (unop, subexpr, pos)) subexpr]

(* returns the string of a binary operation with its subexpressions *)
and
string_of_binop_expr binop lexpr rexpr pos =
  String.concat " "
    [paren_binop_string (Ebinop (lexpr, binop, rexpr, pos)) lexpr;
     string_of_binop binop;
     paren_binop_string (Ebinop (lexpr, binop, rexpr, pos)) rexpr ~isRHS:true]

(* Returns the string of the subexpression of a unary
 * operator, surrounded with parentheses if they are required
 * to preserve the order of operations in the AST             *)
and
paren_unop_string expr subexpr =
  if   (op_binding subexpr) < (op_binding expr)
  then parenthesise (string_of_expr subexpr)
  else string_of_expr subexpr

(* Returns the string of the subexpression of a binary
 * operation, surrounded with parentheses if they are required,
 * as in the following circumstances:
 *   - the precedence of the subexpression operator is lower
 *   - the precedence of the subexpression operator is the
 *     same, the binary operator is not commutative, and
 *     the subexpression is on the right hand side               *)
and
paren_binop_string expr ?isRHS:(isRHS=false) subexpr =
  (* Parens if subex is of lower precedence *)
  (* TODO stop this happening on boolean binops *)
  if (op_binding subexpr) < (op_binding expr) then
    parenthesise (string_of_expr subexpr)
  (* Parens for right hand side of same precedence non-commutative operators *)
  else
    match expr with
    | Ebinop _ ->
        if (op_binding subexpr = op_binding expr) && isRHS then
          parenthesise (string_of_expr subexpr)
        else
          string_of_expr subexpr
    | _         -> string_of_expr subexpr

(* Rval struct assignments look like:
 *     {x = true, y = {a = 8+10, b = true or v}}    *)
let rec string_of_struct_assign rstruct =
  let struct_body =
    String.concat ", " (List.map string_of_struct_entry rstruct)
  in
  String.concat struct_body ["{"; "}"]

(* Rval struct fields look like:
 *     x = 3 | y = true           *)
and
string_of_struct_entry (ident, rvalue, _) =
  String.concat " = " [ident; string_of_rval rvalue]

(* Rvals are either an expression or a struct init *)
and
string_of_rval rval =
  match rval with
  | Rexpr expr      -> string_of_expr expr
  | Rstruct rstruct -> string_of_struct_assign rstruct

(* Native bean type representations *)
let string_of_beantype bt =
  match bt with
  | TBool -> "bool"
  | TInt  -> "int"

(* Typespecs are either native bean types, user-defined, or structs (like in C):
 *   - bean types         -> "int" or "bool"
 *   - user-defined types -> <ident>
 *   - type specification -> {<field>, ...}                                 *)
let rec string_of_typespec ts =
  match ts with
  | TSBeantype bt         -> string_of_beantype bt
  | TSDefinedtype (dt, _) -> dt
  | TSFieldStruct fields  -> let fstrs = List.map string_of_field fields in
                             let body = String.concat ", " fstrs in
                             String.concat body ["{";"}"]

(* Each field looks like:
 *     <ident> : <typespec>  *)
and
string_of_field (ident, typespec, _) =
  String.concat " : " [ident; string_of_typespec typespec]

(* Declarations look like:
 *   <type> <ident>;       *)
let string_of_typedecl (id, beantype, _) =
    let bt_string = string_of_beantype beantype in
    String.concat "" [bt_string; " "; id; ";"]

(* Pass types are either "val" or "ref" *)
let string_of_pass pass_type =
  match pass_type with
  | Pval -> "val"
  | Pref -> "ref"

(* ---- PRINTING HELPER FUNCTIONS ---- *)

(* Print an indent of level n by printing 4*n spaces *)
let print_indent indent_level =
  for i = 1 to indent_level do
    printf "    "
  done

(* TYPEDEF PRINTING FUNCTIONS *)

(* Print a typedef:
 *   - print the "typedef" keyword
 *   - print the string representation of the typespec the typedef
 *     will represent
 *   - print the ident of the typedef                               *)
let print_typedef (typespec, ident, _) =
  printf "typedef ";
  printf "%s" (string_of_typespec typespec);
  printf " %s\n" ident

(* Print a typedef list by printing the first one, then the rest *)
let rec print_typedef_list typedefs =
  match typedefs with
  | []        -> printf "\n"
  | td :: tds -> print_typedef td; print_typedef_list tds

(* ---- DECLARATION PRINTING FUNCTIONS ---- *)

(* Print a variable declaration:
 *   - print the string representation of the typespec of the variable
 *   - print the ident of the variable                                  *)
let print_var_decl (ident, typespec, _) =
  print_indent 1;
  printf "%s %s;\n" (string_of_typespec typespec) ident

(* Print declarations by printing the first one, then the rest *)
let rec print_decl_list dlist =
  match dlist with
  | [decl]      -> print_var_decl decl
  | decl :: ds  -> print_var_decl decl; print_decl_list ds
  | []          -> ()

(* ---- STATEMENT PRINTING FUNCTIONS ---- *)

(* Print an assignment statement:
 *   - print the lvalue being assigned to
 *   - print the ":=" operator
 *   - print the rvalue being assigned     *)
let print_assign indent lval rval =
  print_indent indent;
  printf "%s := %s;\n" (string_of_lval lval) (string_of_rval rval)

(* Print a read statement:
 *   - print "read"
 *   - print the string represenation of the lvalue *)
let print_read indent lval =
  print_indent indent;
  printf "read %s;\n" (string_of_lval lval)

(* Print write:
 *   - print "write"
 *   - if it's an expression:
 *       print the string representation of the expression
 *   - if it's a string:
 *       print the escaped string literal *)
let print_write indent writeable =
  print_indent indent;
  match writeable with
  | WExpr expr  -> printf "write %s;\n" (string_of_expr expr)
  | WString str ->
      printf "write %s;\n" (String.concat "" ["\"";str;"\""])

(* Print a procedure call:
 *   - print the procedure ident
 *   - print the expressions passed to the procedure in the call *)
let print_proc_call indent pname exprs =
  print_indent indent;
  printf "%s(%s);\n" pname (String.concat ", " (List.map string_of_expr exprs))

(* Print an if statement:
 *   - print "if"
 *   - print the boolean guard expression
 *   - print "then"
 *   - print body statements
 *   - if there are else body statements:
 *     + print "else"
 *     + print the else body statements
 *   - print "fi"                          *)
let rec print_if indent expr ?elses:(slist=[]) stmts =
  print_indent indent;
  printf "if %s then\n" (string_of_expr expr);
  print_stmt_list (indent+1) stmts;
  match slist with
  | [] -> print_indent indent ; printf "fi\n" ; ()
  | _ ->
    print_indent indent;
    printf "else\n";
    print_stmt_list (indent+1) slist;
  print_indent indent;
  printf "fi\n"

(* Print a while statement:
 *   - print "while"
 *   - print the boolean guard expression
 *   - print the body statements
 *   - print "od"                         *)
and
print_while indent expr stmts =
  print_indent indent;
  printf "while %s do\n" (string_of_expr expr);
  print_stmt_list (indent+1) stmts;
  print_indent indent;
  printf "od\n";

(* Print a statement list:
 *   - work out the type of the first statement
 *   - print it with the appropriate function
 *   - print the rest of the statements          *)
and
print_stmt_list indent stmt_list =
  let print_stmt stmt =
    match stmt with
    | Assign   (lval, rval, _)   -> print_assign indent lval rval
    | Read     lval              -> print_read indent lval
    | Write    writeable         -> print_write indent writeable
    | If       (expr, stmts)     -> print_if indent expr stmts
    | While    (expr, stmts)     -> print_while indent expr stmts
    | ProcCall (ident, exprs, _) -> print_proc_call indent ident exprs
    | IfElse (expr, if_stmts, else_stmts) ->
        print_if indent expr if_stmts ~elses:else_stmts
  in
  match stmt_list with
  | stmt :: slist   -> print_stmt stmt; print_stmt_list indent slist
  | []              -> ()

(* --- PROCEDURE PRINTING FUNCTIONS --- *)

let print_proc_body (decls, stmts) =
  print_decl_list decls;
  printf "\n";
  print_stmt_list 1 stmts

(* Print a parameter:
 *   - print the pass type
 *   - print the typespec
 *   - print the parameter ident *)
let print_proc_param (pass_type, typespec, ident, _) =
  printf "%s " (string_of_pass pass_type);
  printf "%s " (string_of_typespec typespec);
  printf "%s"  ident

(* Print parameters by printing one, then a comma, then the rest *)
let rec print_proc_param_list param_list =
  match param_list with
  | []          -> ()
  | [param]     -> print_proc_param param
  | param :: ps -> print_proc_param param; printf ", ";
                   print_proc_param_list ps

(* Print a procedure:
 *   - print the "proc" keyword
 *   - print the parameters in the header
 *   - print the declarations in the body
 *   - print the statements in the body
 *   - print the "end" keyword             *)
let print_proc (ident, proc_params, proc_body, _) =
  printf "proc %s(" ident;
  print_proc_param_list proc_params;
  printf ")\n";
  print_proc_body proc_body;
  printf "end"

(* Print procedures by printing one, then the rest *)
let rec print_proc_list plist =
  match plist with
  | []          -> ();
  | [proc]      -> print_proc proc; printf "\n"
  | proc :: ps  -> print_proc proc; printf "\n\n"; print_proc_list ps

(* --- BEAN PROGRAM PRINTING FUNCTION --- *)

(* Print a bean program by printing the typedefs then the procedures *)
let print_program fmt prog =
  print_typedef_list prog.typedefs;
  print_proc_list prog.procs
============================================
src/bean_ast.mli
16:38:20_Friday_20_May_2016
============================================
(* =========================================================== *)
(* Abstract Syntax Tree for the Bean Language                  *)
(* ------------------------------------------                  *)
(* Bean programs are stored as an AST "program", as built by   *)
(* the Bean parser. This program can then be passed to a       *)
(* pretty printer, semantic checker or code generator          *)
(* =========================================================== *)

(* The start and end of a parsed symbol in the file *)
type pos = (Lexing.position * Lexing.position)

(* An identifer for a type, proc or variable *)
type ident = string

(* Base bean types are "bool" and "int" *)
type beantype =
  | TBool
  | TInt

(* Types defined by users using a typedef *)
type definedtype = ident

(* A field within a struct-like type specification.
 * Fields and typespecs are mutually recursive, as in:
 *     {x : int, y : {a : int, b : bool}}              *)
type field = (ident * typespec * pos)

(* A collection of fields, like a C struct *)
and
field_struct = field list

(* A type specification *)
and
typespec =
  | TSBeantype    of beantype
  | TSDefinedtype of (definedtype * pos)
  | TSFieldStruct of field_struct

(* A bean type definition, mapping a type specification to an ident *)
type typedef = (typespec * ident * pos)

(* Bean lvalues are either simple idents, or fields accesses *)
type lvalue =
  | LId    of (ident * pos)
  | LField of (lvalue * ident)

(* Binary operators *)
type binop =
  (* Arithmetic operations *)
  | Op_add | Op_sub | Op_mul | Op_div
  (* Integer comparator operations (int -> int -> bool) *)
  | Op_eq  | Op_neq | Op_lt  | Op_leq | Op_gt | Op_geq
  (* Boolean operations *)
  | Op_and | Op_or

(* Unary operators *)
type unop =
  | Op_minus
  | Op_not

(* Expressions are literals, lvalues, binary operations or unary operations *)
type expr =
  | Ebool  of (bool * pos)
  | Eint   of (int * pos)
  | Elval  of (lvalue * pos)
  | Ebinop of (expr * binop * expr * pos)
  | Eunop  of (unop * expr * pos)

(* Bean can "write" (print) expressions and strings *)
type writeable =
  | WExpr   of expr
  | WString of string

(* A struct/field initialisation rvalue for assignment, like:
 *     var := {x = 3, y = {a = (7+3)*12, b = true}}   *)
type struct_init = (ident * rvalue * pos) list

(* An rvalue is a an object of assignment.
 * Can be an expression, of a struct inititaliser
 * (which assigns fields of the lvalue            *)
and rvalue =
  | Rexpr   of expr
  | Rstruct of struct_init

(* Proc parameter pass type:
 *   - "val" -> by value
 *   - "ref" -> by reference *)
type pass_type =
  | Pval
  | Pref

(* Parameters in a proc header *)
type proc_param = (pass_type * typespec * ident * pos)

(* Statements can be:
 *   - assignment: using ":="
 *   - read: where bean reads from stdin into an lvalue
 *   - write: print a writeable
 *   - if, if-else, while: conditional statements
 *   - proc-call: calling a procedure                    *)
type stmt =
  | Assign   of (lvalue * rvalue * pos)
  | Read     of lvalue
  | Write    of writeable
  | If       of (expr * stmt list)
  | IfElse   of (expr * stmt list * stmt list)
  | While    of (expr * stmt list)
  | ProcCall of (ident * expr list * pos)

(* A declaration declares an ident as having a type *)
type decl = (ident * typespec * pos)

(* The body of a procedure, composed of declarations followed by statements *)
type proc_body = (decl list * stmt list)

(* A procedure has an ident, a list of parameters and a body
 * composed of declarations followed by statements           *)
type proc = (ident * proc_param list * proc_body * pos)

(* A bean program is typedefs followed by procedure definitions *)
type program = {
  typedefs : typedef list;
  procs    : proc    list
}

(* Convenient top level type alias to pass to other modules *)
type t = program


val get_pos_info: (Lexing.position * Lexing.position) ->
                      (string * (int * int) * (int * int))

val get_lval_pos: lvalue -> pos
============================================
src/bean_oz.mli
16:38:20_Friday_20_May_2016
============================================
val generate_oz_code: Bean_intermediate_code.code -> string
============================================
src/bean_oz.ml
16:38:20_Friday_20_May_2016
============================================
module IR = Bean_intermediate_code

(* ---- CODE PRINTING FUNCTIONS ---- *)

let write = Printf.sprintf

let write_push_stack frame_size =
  write "push_stack_frame %d" frame_size

let write_pop_stack frame_size =
  write "pop_stack_frame %d" frame_size

let write_load (IR.Reg r) (IR.StackSlot s) =
  write "load r%d, %d" r s

let write_store (IR.StackSlot s) (IR.Reg r) =
  write "store %d, r%d" s r

let write_load_addr (IR.Reg r) (IR.StackSlot s) =
  write "load_address r%d, %d" r s

let write_load_ind (IR.Reg r1) (IR.Reg r2) =
  write "load_indirect r%d, r%d" r1 r2

let write_store_ind (IR.Reg r1) (IR.Reg r2) =
  write "store_indirect r%d, r%d" r1 r2

let write_int_const (IR.Reg r) imm =
  write "int_const r%d, %d" r imm

let write_str_const (IR.Reg r) str =
  write "string_const r%d, \"%s\"" r str

let write_add_int (IR.Reg r1) (IR.Reg r2) (IR.Reg r3) =
  write "add_int r%d, r%d, r%d" r1 r2 r3

let write_sub_int (IR.Reg r1) (IR.Reg r2) (IR.Reg r3) =
  write "sub_int r%d, r%d, r%d" r1 r2 r3

let write_mul_int (IR.Reg r1) (IR.Reg r2) (IR.Reg r3) =
  write "mul_int r%d, r%d, r%d" r1 r2 r3

let write_div_int (IR.Reg r1) (IR.Reg r2) (IR.Reg r3) =
  write "div_int r%d, r%d, r%d" r1 r2 r3

let write_add_offset (IR.Reg r1) (IR.Reg r2) (IR.Reg r3) =
  write "add_offset r%d, r%d, r%d" r1 r2 r3

let write_sub_offset (IR.Reg r1) (IR.Reg r2) (IR.Reg r3) =
  write "sub_offset r%d, r%d, r%d" r1 r2 r3

let write_cmp_eq (IR.Reg r1) (IR.Reg r2) (IR.Reg r3) =
  write "cmp_eq_int r%d, r%d, r%d" r1 r2 r3

let write_cmp_neq (IR.Reg r1) (IR.Reg r2) (IR.Reg r3) =
  write "cmp_ne_int r%d, r%d, r%d" r1 r2 r3

let write_cmp_lt (IR.Reg r1) (IR.Reg r2) (IR.Reg r3) =
  write "cmp_lt_int r%d, r%d, r%d" r1 r2 r3

let write_cmp_leq (IR.Reg r1) (IR.Reg r2) (IR.Reg r3) =
  write "cmp_le_int r%d, r%d, r%d" r1 r2 r3

let write_cmp_gt (IR.Reg r1) (IR.Reg r2) (IR.Reg r3) =
  write "cmp_gt_int r%d, r%d, r%d" r1 r2 r3

let write_cmp_geq (IR.Reg r1) (IR.Reg r2) (IR.Reg r3) =
  write "cmp_ge_int r%d, r%d, r%d" r1 r2 r3

let write_and (IR.Reg r1) (IR.Reg r2) (IR.Reg r3) =
  write "and r%d, r%d, r%d" r1 r2 r3

let write_or (IR.Reg r1) (IR.Reg r2) (IR.Reg r3) =
  write "or r%d, r%d, r%d" r1 r2 r3

let write_not (IR.Reg r1) (IR.Reg r2) =
  write "not r%d, r%d" r1 r2

let write_move (IR.Reg r1) (IR.Reg r2) =
  write "move r%d, r%d" r1 r2

let write_branch_true (IR.Reg r) (IR.Label label) =
  write "branch_on_true r%d, %s" r label

let write_branch_false (IR.Reg r) (IR.Label label) =
  write "branch_on_false r%d, %s" r label

let write_branch_uncond (IR.Label label) =
  write "branch_uncond %s" label

let write_call (IR.Label label) =
  write "call %s" label

let write_call_builtin builtin =
  let builtin_str =
    match builtin with
    | IR.ReadInt     -> "read_int"
    | IR.ReadBool    -> "read_bool"
    | IR.PrintInt    -> "print_int"
    | IR.PrintBool   -> "print_bool"
    | IR.PrintString -> "print_string"
  in
  write "call_builtin %s" builtin_str

let write_return =
  write "return"

let write_halt =
  write "halt"

let write_block_label (IR.Label label) =
  write "%s:" label

let write_debug_reg (IR.Reg r) =
  write "debug_reg r%d" r

let write_debug_slot (IR.StackSlot s) =
  write "debug_slot %d" s

let write_debug_stack =
  write "debug_stack"

let write_instr instr =
  match instr with
  (* Stack Manipulation *)
  | IR.PushStackFrame  frame_size -> write_push_stack frame_size
  | IR.PopStackFrame   frame_size -> write_pop_stack frame_size
  (* Register Store/Load *)
  | IR.Load          (reg0, slot) -> write_load      reg0 slot
  | IR.Store         (slot, reg0) -> write_store     slot reg0
  | IR.LoadAddress   (reg0, slot) -> write_load_addr reg0 slot
  | IR.LoadIndirect  (reg1, reg2) -> write_load_ind  reg1 reg2
  | IR.StoreIndirect (reg1, reg2) -> write_store_ind reg1 reg2
  (* Register Immediate Operation *)
  | IR.IntConst        (reg, imm) -> write_int_const reg imm
  | IR.StringConst     (reg, str) -> write_str_const reg str
  (* Integer Arithmetic Operations *)
  | IR.AddInt        (r1, r2, r3) -> write_add_int r1 r2 r3
  | IR.SubInt        (r1, r2, r3) -> write_sub_int r1 r2 r3
  | IR.MulInt        (r1, r2, r3) -> write_mul_int r1 r2 r3
  | IR.DivInt        (r1, r2, r3) -> write_div_int r1 r2 r3
  (* Address Offset Operations *)
  | IR.AddOffset     (r1, r2, r3) -> write_add_offset r1 r2 r3
  | IR.SubOffset     (r1, r2, r3) -> write_sub_offset r1 r2 r3
  (* Integer Comparison Operations *)
  | IR.CmpEqInt      (r1, r2, r3) -> write_cmp_eq  r1 r2 r3
  | IR.CmpNeqInt     (r1, r2, r3) -> write_cmp_neq r1 r2 r3
  | IR.CmpLtInt      (r1, r2, r3) -> write_cmp_lt  r1 r2 r3
  | IR.CmpLeqInt     (r1, r2, r3) -> write_cmp_leq r1 r2 r3
  | IR.CmpGtInt      (r1, r2, r3) -> write_cmp_gt  r1 r2 r3
  | IR.CmpGeqInt     (r1, r2, r3) -> write_cmp_geq r1 r2 r3
  (* Boolean Arithmetic Operations *)
  | IR.And           (r1, r2, r3) -> write_and r1 r2 r3
  | IR.Or            (r1, r2, r3) -> write_or  r1 r2 r3
  | IR.Not               (r1, r2) -> write_not r1 r2
  (* Move *)
  | IR.Move              (r1, r2) -> write_move r1 r2
  (* Branch Instructions *)
  | IR.BranchOnTrue  (reg, label) -> write_branch_true   reg label
  | IR.BranchOnFalse (reg, label) -> write_branch_false  reg label
  | IR.BranchUncond         label -> write_branch_uncond label
  (* Calls *)
  | IR.Call                 label -> write_call         label
  | IR.CallBuiltin        builtin -> write_call_builtin builtin
  | IR.Return                     -> write_return
  (* Emulator Halt *)
  | IR.Halt                       -> write_halt
  | IR.BlockLabel           label -> write_block_label label
  (* Debug Instructions *)
  | IR.DebugReg               reg -> write_debug_reg   reg
  | IR.DebugSlot       stack_slot -> write_debug_slot  stack_slot
  | IR.DebugStack                 -> write_debug_stack

let generate_oz_code ir_code =
  String.concat "\n" (List.map write_instr ir_code)
============================================
src/bean_ast.ml
16:38:20_Friday_20_May_2016
============================================
(* =========================================================== *)
(* Abstract Syntax Tree for the Bean Language                  *)
(* ------------------------------------------                  *)
(* Bean programs are stored as an AST "program", as built by   *)
(* the Bean parser. This program can then be passed to a       *)
(* pretty printer, semantic checker or code generator          *)
(* =========================================================== *)

(* The start and end of a parsed symbol in the file *)
type pos = (Lexing.position * Lexing.position)

(* An identifer for a type, proc or variable *)
type ident = string

(* Base bean types are "bool" and "int" *)
type beantype =
  | TBool
  | TInt

(* Types defined by users using a typedef *)
type definedtype = ident

(* A field within a struct-like type specification.
 * Fields and typespecs are mutually recursive, as in:
 *     {x : int, y : {a : int, b : bool}}              *)
type field = (ident * typespec * pos)

(* A collection of fields, like a C struct *)
and
field_struct = field list

(* A type specification *)
and
typespec =
  | TSBeantype    of beantype
  | TSDefinedtype of (definedtype * pos)
  | TSFieldStruct of field_struct

(* A bean type definition, mapping a type specification to an ident *)
type typedef = (typespec * ident * pos)

(* Bean lvalues are either simple idents, or fields accesses *)
type lvalue =
  | LId    of (ident * pos)
  | LField of (lvalue * ident)

(* Binary operators *)
type binop =
  (* Arithmetic operations *)
  | Op_add | Op_sub | Op_mul | Op_div
  (* Integer comparator operations (int -> int -> bool) *)
  | Op_eq  | Op_neq | Op_lt  | Op_leq | Op_gt | Op_geq
  (* Boolean operations *)
  | Op_and | Op_or

(* Unary operators *)
type unop =
  | Op_minus
  | Op_not

(* Expressions are literals, lvalues, binary operations or unary operations *)
type expr =
  | Ebool  of (bool * pos)
  | Eint   of (int * pos)
  | Elval  of (lvalue * pos)
  | Ebinop of (expr * binop * expr * pos)
  | Eunop  of (unop * expr * pos)

(* Bean can "write" (print) expressions and strings *)
type writeable =
  | WExpr   of expr
  | WString of string

(* A struct/field initialisation rvalue for assignment, like:
 *     var := {x = 3, y = {a = (7+3)*12, b = true}}   *)
type struct_init = (ident * rvalue * pos) list

(* An rvalue is a an object of assignment.
 * Can be an expression, of a struct inititaliser
 * (which assigns fields of the lvalue            *)
and rvalue =
  | Rexpr   of expr
  | Rstruct of struct_init

(* Proc parameter pass type:
 *   - "val" -> by value
 *   - "ref" -> by reference *)
type pass_type =
  | Pval
  | Pref

(* Parameters in a proc header *)
type proc_param = (pass_type * typespec * ident * pos)

(* Statements can be:
 *   - assignment: using ":="
 *   - read: where bean reads from stdin into an lvalue
 *   - write: print a writeable
 *   - if, if-else, while: conditional statements
 *   - proc-call: calling a procedure                    *)
type stmt =
  | Assign   of (lvalue * rvalue * pos)
  | Read     of lvalue
  | Write    of writeable
  | If       of (expr * stmt list)
  | IfElse   of (expr * stmt list * stmt list)
  | While    of (expr * stmt list)
  | ProcCall of (ident * expr list * pos)

(* A declaration declares an ident as having a type *)
type decl = (ident * typespec * pos)

(* The body of a procedure, composed of declarations followed by statements *)
type proc_body = (decl list * stmt list)

(* A procedure has an ident, a list of parameters and a body
 * composed of declarations followed by statements           *)
type proc = (ident * proc_param list * proc_body * pos)

(* A bean program is typedefs followed by procedure definitions *)
type program = {
  typedefs : typedef list;
  procs    : proc    list
}

(* Convenient top level type alias to pass to other modules *)
type t = program


(* ---- HELPER FUNCTIONS FOR OTHER MODULES ---- *)
let get_pos_info (start_pos, end_pos) =
  let get_ln_col pos = 
    let start_ln  = pos.Lexing.pos_lnum in
    let start_col = pos.Lexing.pos_cnum - pos.Lexing.pos_bol + 1 in
    (start_ln, start_col)
  in
  let fname   = start_pos.Lexing.pos_fname in
  let start_p = get_ln_col start_pos in
  let end_p   = get_ln_col end_pos in
  (fname, start_p, end_p)

let rec get_lval_pos lval =
  match lval with
  | LId (_, p) -> p
  | LField (lval, _) -> get_lval_pos lval

============================================
src/bean_semantic.mli
16:38:20_Friday_20_May_2016
============================================
exception Semantic_error       of string * Bean_ast.pos

exception Type_error           of string * Bean_ast.pos
exception Arity_mismatch       of string * Bean_ast.pos
exception Assign_type_mismatch of Bean_symtbl.type_symbol * Bean_symtbl.type_symbol * Bean_ast.pos
exception Reference_pass       of string * Bean_ast.pos
exception Read_struct          of string * Bean_ast.pos
exception Write_struct         of string * Bean_ast.pos
exception Var_name_is_type     of string * Bean_ast.pos
exception Var_name_is_param    of string * Bean_ast.pos
exception Param_name_is_type   of string * Bean_ast.pos
exception Main_has_nonzero_arity
exception No_main_proc
exception Evil                 of string

val check_has_main: Bean_symtbl.t -> unit

val check_param_name: Bean_symtbl.t -> Bean_ast.ident -> Bean_ast.ident -> unit

val check_decl_name: Bean_symtbl.t -> Bean_ast.ident -> Bean_ast.ident -> Bean_ast.pos -> unit

val check_stmt: Bean_symtbl.t -> Bean_ast.ident -> Bean_ast.stmt -> unit
============================================
src/Makefile
16:38:20_Friday_20_May_2016
============================================
# ===========================================================
# Makefile for Building the Bean Compiler and Pretty Printer
# ----------------------------------------------------------
# This makefile will generate a single binary, "bean",
# along with a bytecode executeable, "bean.byte". This
# binary will execute the bean compiler on a given input
# program, like so:
# 	"./bean [-p] <bean-filepath>"
# Where the "-p" option tells the compiler to pretty print
# instead of compiling.
#
# Typical usage to build the compiler in an otherwise
# empty directory is:
# 	"make"
# If you wish to remove files from a previous build, run:
# 	"make clean"
# If you wish remove the binary and bytecode file generated
# too before you build, run:
# 	"make clobber"
# A easy way to use this command each time is:
# 	"make clobber && make"
# If "make" is failing, you may need to generate a
# dependency file first and try again, like:
# 	"make depend"
# Note that there is no "make install" command, you must do
# that yourself, sorry.
# ===========================================================

TARGETS = bean
TARGETS_BYTE=$(TARGETS:%=%.byte)

MODULES = bean_ast \
	  bean_lex \
	  bean_parse \
	  bean_pprint \
	  bean_symtbl \
	  bean_semantic \
	  bean_intermediate_code \
	  bean_oz
MLFILES = $(addsuffix .ml, $(MODULES))
CMOFILES = $(addsuffix .cmo, $(MODULES))
CMXFILES = $(addsuffix .cmx, $(MODULES))

ALLMODULES = $(MODULES) bean

OCAMLLEX = ocamllex
# The "-v" flag set here will generate an output file describing
# the table generated by ocamllex. Remove it if you don't want this
OCAMLYACC = ocamlyacc -v
OCAMLDEP = ocamldep

OCAMLFLAGS =

# Generate both native and bytecode executables
all : opt byte
# Generate bytecode executable
byte: $(TARGETS_BYTE)
# Generate native binary executable
opt: $(TARGETS)

# OCaml intermediary file generation
%.cmi: %.mli
	ocamlc $(OCAMLFLAGS) -c $<

%.cmo: %.ml
	ocamlc $(OCAMLFLAGS) -g -c $<

%.cmx: %.ml
	ocamlopt $(OCAMLOPTFLAGS) -g -c $<

%.ml: %.mll
	$(OCAMLLEX) $^

%.ml %.mli: %.mly
	$(OCAMLYACC) $^

bean.byte : $(CMOFILES) bean.cmo
	ocamlc -g -o $@ $^

bean : $(CMXFILES) bean.cmx
	ocamlopt -g -o $@ $^

# Clean the working directory of generated intermediary files
clean :
	rm -f *.cmo *.cmi *.cmx *.o
	rm -f bean_lex.ml bean_parse.ml bean_parse.mli

# Clean the working directory of generated binaries too
clobber : clean
	rm -f $(TARGETS) $(TARGETS_BYTE)

.PHONY : clean clobber depend

# include depend
depend: bean_lex.ml bean_parse.ml
	$(OCAMLDEP) bean.ml bean.mli $(ALLMODULES:%=%.mli) $(ALLMODULES:%=%.ml) >Makefile.depend

-include Makefile.depend
============================================
src/bean_semantic.old.ml
16:38:20_Friday_20_May_2016
============================================
module Sym = Bean_symtbl
module AST = Bean_ast
module PP  = Bean_pprint

exception Undefined_variable of (AST.ident * AST.pos)
exception Undefined_proc of (AST.ident * AST.pos)
exception Undefined_field of (AST.ident * AST.pos)
exception Type_error of (AST.ident * AST.pos)

(* Get the position out of an lval *)
let rec get_lval_pos lval =
  match lval with
  | AST.LId (_, pos)      -> pos
  | AST.LField (field, _) -> get_lval_pos field

(* Return the type of an lvalue as stored in the Symbol Table *)
let rec get_lval_type proc lval =
  let params = proc.Sym.proc_params in
  let decls  = proc.Sym.proc_decls in
  let get_entry (id, pos) =
    if Hashtbl.mem params id
    then
      let param = Hashtbl.find params id in
      param.Sym.param_type
    else if Hashtbl.mem decls id
    then
      let decl = Hashtbl.find decls id in
      decl.Sym.decl_type
    else
      raise (Undefined_variable (id, pos))
  in
  match lval with
  | AST.LId lid           -> get_entry lid
  | AST.LField (lval, id) ->
      (* TODO THIS IS BROKEN *)
      get_lval_type proc lval
  
(* Check that an lval is valid when we don't care about the type *)
let check_lval pos proc lval =
  match get_lval_type pos proc lval with
  | _ -> true

(* Returns the type of an expression by recursive check.
 * Since a type can only be consistent if it returns, a type
 * check is also performed                                   *)
let rec get_expr_type proc expr =
  match expr with
  | AST.Ebool _ -> AST.TBool
  | AST.Eint  _ -> AST.TInt
  | AST.Elval (lval, pos) -> get_lval_type proc lval
  | AST.Eunop (pos, unop, expr) ->
      let unop_type = get_unop_type unop in
      let expr_type = get_expr_type proc expr in
      if unop_type = expr_type then unop_type else
        raise (Type_error (PP.string_of_unop unop, pos))
  | AST.Ebinop (pos, lexpr, binop, rexpr) ->
      let binop_type = get_binop_type binop in
      let lexpr_type = get_expr_type proc lexpr in
      let rexpr_type = get_expr_type proc rexpr in
      if binop_type = lexpr_type && binop_type = rexpr_type
      then binop_type
      else raise (Type_error (PP.string_of_binop binop, pos))

(* Uses the type check in get_expr_type in situations where
 * we don't want the type it returns                        *)
let check_expr proc expr =
  match get_expr_type proc expr with
  | _ -> true

(* Check that assigning lvals to rvals is correct:
 *   - Ensure types of lval and rval are the same
 *   - If rval is a struct, check that every field is in the lval
 *   - Recursion supports nested struct assignment                 *)
let rec are_asgn_type_match proc pos lval_t rval =
  match rval with
  | AST.Rstruct fields -> check_field_asgn proc pos lval_t fields
  | AST.Rexpr (_, expr) ->
      if lval_t = get_expr_type proc expr
      then true
      else raise (Type_error (":=", pos))

(* Checks that the lvalue being assigned a field is
 * valid for assignment:
 *   - check it has a struct type
 *   - check the struct fields recursively          *)
and
check_field_asgn proc pos lval_t fields =
  match lval_t with
  | Sym.TTypedef (_, typedef) -> is_struct_isomorphic proc typedef fields
  | _ -> raise (Type_error (":=", pos))

(* Check a struct rvalue assignment is valid:
 *   - checks every rvalue field corresponds to an
 *     lvalue of the same identifier
 *   - checks the assignment of every field is valid *)
and
is_struct_isomorphic proc typedef (_, fields) =
  let go (pos, rid, rval) isValid =
    let lfield =
      try
        Hashtbl.find typedef.Sym.td_fields rid
      with
        Not_found -> raise (Undefined_field (rid, pos))
    in
    isValid && are_asgn_type_match proc pos lfield.Sym.field_type rval
  in
  List.fold_right go fields true

(* Check an rvalue:
 *   - check expressions recursively *)
let rec check_rval proc rval =
  let go (_, _, rvalue) isValid = isValid && check_rval proc rvalue in
  match rval with
  | AST.Rexpr (_, expr) -> check_expr proc expr
  | AST.Rstruct (_, structs) -> List.fold_right go structs true

(* Check an lvalue is a readable type.
 * It's currently assumed all lvalues are "readable" *)
let check_readable _ _ = true

(* Check an assignment statement:
 *   - check lvalue
 *   - check rvalue
 *   - check lvalue has the same type as rvalue *)
let check_asgn proc (pos, lval, rval) =
  let lval_type = get_lval_type proc pos lval in
  are_asgn_type_match proc pos lval_type rval


(* Check a read statement:
 *   - check lvalue
 *   - check the lvalue is a readable type *)
let check_read proc (pos, lval) =
  check_lval proc pos lval && check_readable proc lval

(* Check a write statement:
 *   - strings are always writeable
 *   - expressions are writeable if they are valid *)
let check_write proc (_, write) =
  match write with
  | AST.WString _ -> true
  | AST.WExpr (_, expr) -> check_expr proc expr

let get_prochead_symtype proc (_, _, _, id) =
  let heads = proc.Sym.proc_heads in
  let h = Hashtbl.find heads id in
  h.Sym.head_type

(* Check a proc call statement:
 *   - check the proc is defined
 *   - check the arity is correct
 *   - check the types of the arguments are correct *)
let check_pcall procs_tbl heads proc (pos, id, exprs) =
  let asgn_pairs = List.combine heads exprs in
  let go (head, expr) isValid =
    isValid
    && get_prochead_symtype proc head = get_expr_type proc expr
    (* TODO check proc assignment
     * -- record proc arg position in symtab *)
  in
  if Hashtbl.mem procs_tbl id then
    List.fold_right go asgn_pairs true
  else
    raise (Undefined_proc (id, pos))

(* Check conditionals:
 *   - check conditional expression
 *   - check condition of of boolean type
 *   - check statements in condition body *)
let rec check_cond procs_tbl heads proc cond =
  let go stmt isValid = isValid && check_stmt procs_tbl heads proc stmt in
  let check_cond_expr proc expr =
    check_expr proc expr
    && get_expr_type proc expr = Sym.TBool
  in
  match cond with
  | AST.If (_, expr, stmts) ->
      check_cond_expr proc expr
      && List.fold_right go stmts true
  | AST.IfElse (_, expr, ifStmts, elStmts) ->
      check_cond_expr proc expr
      && List.fold_right go ifStmts true
      && List.fold_right go elStmts true
  | AST.While (_, expr, stmts) ->
      check_cond_expr proc expr
      && List.fold_right go stmts true
  (* If an expression is unmatched here, it's a compiler error;
   * if a non-conditional statement gets here, it's a bug and not
   * the programmer's fault                                       *)

(* Check semantics of a single statement, with the possibilities of:
 *   - assignment
 *   - read in
 *   - write out
 *   - if, ifelse, while
 *   - proc calls                                                    *)
and check_stmt procs_tbl heads proc stmt =
  match stmt with
  | AST.Assign asgn     -> check_asgn proc asgn
  | AST.Read read       -> check_read proc read
  | AST.Write write     -> check_write proc write
  | AST.ProcCall pcall  -> check_pcall procs_tbl heads proc pcall
  (* Put conditionals together to minimise mutual recursion *)
  | condStmt            -> check_cond procs_tbl heads proc condStmt

(* Check semantics in a single proc by checking
 * every statement in the body of that proc     *)
let check_proc procs_tbl (_, proc_id, heads, _, stmts) =
  let proc = Hashtbl.find procs_tbl proc_id in
  (* Fold checks over all statements in a proc body *)
  let go stmt isValid = isValid && check_stmt procs_tbl heads proc stmt in
  List.fold_right go stmts true

(* Check semantics for all procs in a bean program, with reference
 * to the typedefs in the symbol table                             *)
let check_semantics symtbl program =
  let procs_tbl = symtbl.Sym.sym_procs in
  (* Fold over all procs and return true if they are all valid *)
  let go proc isValid = isValid && check_proc procs_tbl proc in
  let ps = program.AST.procs in 
  List.fold_right go ps true
============================================
src/bean_semantic.ml
16:38:20_Friday_20_May_2016
============================================
module AST = Bean_ast
module Sym = Bean_symtbl
module P = Bean_pprint

(* General semantic error to pass out *)
(* TODO decide if this should be used, or if errors should be passed out
 * for bean.ml to handle (better for integration with linters, etc.)     *)
exception Semantic_error of string * AST.pos

(* Like Haskell's `undefined`; stops the compiler from whinging *)
exception Not_yet_implemented

(* TODO pass expression names out or something, use pretty printer functions
 * to show the user where compilation failed in a nice way                   *)

(* Internal semantic errors *)
exception Type_error           of string * AST.pos
exception Arity_mismatch       of string * AST.pos
exception Assign_type_mismatch of Sym.type_symbol * Sym.type_symbol * AST.pos
exception Reference_pass       of string * AST.pos
exception Read_struct          of string * AST.pos
exception Write_struct         of string * AST.pos
exception Var_name_is_type     of string * AST.pos
exception Var_name_is_param    of string * AST.pos
exception Param_name_is_type   of string * AST.pos
exception Main_has_nonzero_arity
exception No_main_proc
exception Evil                 of string

(* ----- HELPER FUNCTIONS ----- *)

let get_expr_pos expr =
  match expr with
  | AST.Ebool  (_, p)       -> p
  | AST.Eint   (_, p)       -> p
  | AST.Elval  (_, p)       -> p
  | AST.Eunop  (_, _, p)    -> p
  | AST.Ebinop (_, _, _, p) -> p

let get_unop_type unop =
  match unop with
  | AST.Op_not   -> Sym.STBeantype AST.TBool
  | AST.Op_minus -> Sym.STBeantype AST.TInt

let get_binop_arg_type binop =
  match binop with
  | AST.Op_eq  | AST.Op_neq 
  | AST.Op_lt  | AST.Op_leq
  | AST.Op_gt  | AST.Op_geq
  | AST.Op_add | AST.Op_sub 
  | AST.Op_mul | AST.Op_div -> Sym.STBeantype AST.TInt
  | AST.Op_and | AST.Op_or  -> Sym.STBeantype AST.TBool

let get_binop_type binop =
  match binop with
  | AST.Op_eq  | AST.Op_neq 
  | AST.Op_lt  | AST.Op_leq
  | AST.Op_gt  | AST.Op_geq
  | AST.Op_and | AST.Op_or  -> Sym.STBeantype AST.TBool
  | AST.Op_add | AST.Op_sub 
  | AST.Op_mul | AST.Op_div -> Sym.STBeantype AST.TInt

let check_type_defined symtbl type_id pos =
  if Hashtbl.mem symtbl.Sym.sym_tds type_id then
    ()
  else
    raise (Sym.Undefined_type (type_id, pos))

let check_no_duplicate_type symtbl type_id pos =
  if Hashtbl.mem symtbl.Sym.sym_tds type_id then
    raise (Sym.Duplicate_type (type_id, pos))
  else
    ()

let check_var_defined symtbl proc_id var_id pos =
  let proc_tbl = Hashtbl.find symtbl.Sym.sym_procs proc_id in
  if Hashtbl.mem proc_tbl.Sym.proc_sym_tbl var_id then
    ()
  else
    raise (Sym.Undefined_variable (var_id, pos))

let check_param_name symtbl proc_id param_id =
  let (_, scope, _, pos) = Sym.get_var_sym symtbl proc_id param_id in
  if Hashtbl.mem symtbl.Sym.sym_tds param_id then
    raise (Param_name_is_type (param_id, pos))
  else
    ()

let check_decl_name symtbl proc_id var_id pos =
  let (_, scope, _, _) = Sym.get_var_sym symtbl proc_id var_id in
  if Hashtbl.mem symtbl.Sym.sym_tds var_id then
    raise (Var_name_is_type (var_id, pos))
  else
    match scope with
    | Sym.SDecl                     -> ()
    | Sym.SParamRef | Sym.SParamVal ->
        raise (Var_name_is_param (var_id, pos))

let check_proc_defined symtbl proc_id pos =
  if Hashtbl.mem symtbl.Sym.sym_procs proc_id then
    ()
  else
    raise (Sym.Undefined_proc (proc_id, pos))

let check_proc_call_arity symtbl callee_id args pos =
  let params = Sym.get_param_list symtbl callee_id in
  if List.length params = List.length args then
    ()
  else
    raise (Arity_mismatch (callee_id, pos))

let check_has_main symtbl =
  let proc_tbl = symtbl.Sym.sym_procs in
  if Hashtbl.mem proc_tbl "main" then
    let main_proc = Hashtbl.find proc_tbl "main" in
    if List.length main_proc.Sym.proc_params = 0 then
      ()
    else
      raise Main_has_nonzero_arity
  else
    raise No_main_proc

let check_has_field symtbl proc_id lval field_name =
  let lval_t_sym = Sym.get_lval_type symtbl proc_id lval in
  match lval_t_sym with
  | Sym.STBeantype _ ->
      (*raise (Sym.Undefined_field (field_name, AST.get_lval_pos lval))*)
      ()
  | Sym.STFieldStruct fields ->
      if Hashtbl.mem fields field_name then
        ()
      else
        raise (Sym.Undefined_field (field_name, AST.get_lval_pos lval))

let check_lval_name symtbl proc_id lval =
  let pos = AST.get_lval_pos lval in
  let rec get_field_name lval =
    match lval with
    | AST.LId (id, _)           -> id
    | AST.LField (sub_lval, id) -> get_field_name sub_lval
  in
  match lval with
  | AST.LId (id, _)       -> check_var_defined symtbl proc_id id pos
  | AST.LField (lval, id) ->
      check_var_defined symtbl proc_id id pos;
      let field_name = get_field_name (AST.LField (lval, id)) in
      check_has_field symtbl proc_id (AST.LField (lval, id)) field_name

let get_expr_type symtbl proc_id expr =
  match expr with
  | AST.Eint   _                -> Sym.STBeantype AST.TInt
  | AST.Ebool  _                -> Sym.STBeantype AST.TBool
  | AST.Elval  (lval, _)        -> Sym.get_lval_type symtbl proc_id lval
  (* Trust that a sub-expression will be checked; we can't have this
   * call check_expr AND check_expr call this --> infinite loop      *)
  | AST.Eunop  (unop, _, _)     -> get_unop_type unop
  | AST.Ebinop (_, binop, _, _) -> get_binop_type binop
  (* TODO Check the expression then return the type *)

let rec are_type_equivalent t_sym_a t_sym_b =
  let match_bt bt_a bt_b =
    match (bt_a, bt_b) with
    | (AST.TBool, AST.TBool)
    | (AST.TInt,  AST.TInt)  -> true
    | _                      -> false
  in
  let match_fields fs_a fs_b =
    let go field_tbl id (t_sym, _) isMatch =
      try
        let (field_tsym, _) = Hashtbl.find field_tbl id in
        are_type_equivalent t_sym field_tsym
      with
      | Not_found -> false
    in
    (* Fold over the fields and make sure they all match symetrically *)
    Hashtbl.fold (go fs_a) fs_b true && Hashtbl.fold (go fs_b) fs_a true
  in
  match (t_sym_a, t_sym_b) with
  | (Sym.STBeantype bt_a,    Sym.STBeantype bt_b)    -> match_bt bt_a bt_a
  | (Sym.STFieldStruct fs_a, Sym.STFieldStruct fs_b) -> match_fields fs_a fs_b
  | _                                                -> false

let rec check_assignment_type symtbl proc_id type_sym rexpr pos =
  match (type_sym, rexpr) with
  | (Sym.STBeantype bt, AST.Rexpr expr) ->
      let expr_type = get_expr_type symtbl proc_id expr in
      let pos       = get_expr_pos expr in
      if expr_type = Sym.STBeantype bt then
        ()
      else
        raise (Type_error ("Assignment types do not match", pos))
  | (Sym.STFieldStruct field_tbl, AST.Rstruct rexpr_list) ->
      let go (field_id, sub_rv, pos) () =
        let (field_type, _) =
          try
            Hashtbl.find field_tbl field_id
          with
          | Not_found -> raise (Sym.Undefined_field ("No field", pos))
        in
        check_assignment_type symtbl proc_id field_type sub_rv pos
      in
      List.fold_right go rexpr_list ()
  (* TODO assign struct lvals to struct lvals *)
  | (_, _) ->
      raise (Type_error ("Assignment types do not match", pos))
  (* TODO Maybe improve the way this last check works*)

let check_pass_type symtbl caller_id callee_id param_id arg_expr =
  let param_sym = Sym.get_var_sym symtbl callee_id param_id in
  let (_, scope, _, _) = param_sym in
  match scope with
  | Sym.SDecl     -> raise (Evil "Function has param declared as decl")
  | Sym.SParamVal -> ()
  | Sym.SParamRef ->
      match arg_expr with
      | AST.Elval _ -> ()
      | _           ->
          let pos = get_expr_pos arg_expr in
          raise (Reference_pass (P.string_of_expr arg_expr, pos))

let is_primitive symtbl proc_id lval =
  let type_sym = Sym.get_lval_type symtbl proc_id lval in
  match type_sym with
  | Sym.STBeantype    _ -> true
  | Sym.STFieldStruct _ -> false

let get_rval_type symtbl proc_id rval =
  match rval with
  | AST.Rexpr expr -> get_expr_type symtbl proc_id expr
  | AST.Rstruct _ ->
      (* TODO Figure out what we actually need to do here *)
      raise Not_yet_implemented

(* ----- AST STRUCTURE CHECK FUNCTIONS ----- *)

let rec check_expr symtbl proc_id expr =
  match expr with
  | AST.Eint _ | AST.Ebool _     -> ()
  | AST.Elval (lval, _)          -> check_lval_name symtbl proc_id lval
  | AST.Eunop (op, subexpr, pos) ->
      check_expr symtbl proc_id subexpr;
      let op_type = get_unop_type op in
      if op_type = get_expr_type symtbl proc_id subexpr then
        ()
      else
        raise (Type_error ("Type error in `"^P.string_of_expr expr^"`", pos))
  | AST.Ebinop (lexpr, op, rexpr, pos) ->
      check_expr symtbl proc_id lexpr;
      check_expr symtbl proc_id rexpr;
      let op_arg_type = get_binop_arg_type op in
      let lexpr_type  = get_expr_type symtbl proc_id lexpr in
      let rexpr_type  = get_expr_type symtbl proc_id rexpr in
      if (op_arg_type = lexpr_type) && (op_arg_type = rexpr_type) then
        ()
      else
        raise (Type_error ("Type error in `"^P.string_of_expr expr^"`", pos))

let check_primitive_asgn symtbl proc_id beantype arg_expr =
  let expr_type = get_expr_type symtbl proc_id arg_expr in
  if expr_type = beantype then
    ()
  else
    let pos = get_expr_pos arg_expr in
    raise (Type_error ("Type error in `"^P.string_of_expr arg_expr^"`", pos))

let check_param_asgn symtbl caller_id callee_id param_id arg_expr =
  let error  =
    let pos = get_expr_pos arg_expr in
    let expr_str = P.string_of_expr arg_expr in
    let msg = String.concat " "
      ["Types of expression"; expr_str; "and parameter"; param_id;
       "in procedure"; callee_id; "do not match"]
    in
    Type_error (msg, pos)
  in
  let arg_type = get_expr_type symtbl caller_id arg_expr in
  let match_beantype bt1 bt2 =
    match (bt1, bt2) with
    | (AST.TBool, AST.TBool) -> ()
    | (AST.TInt,  AST.TInt)  -> ()
    | _                      -> raise error
  in
  let rec check_field targ_fields id (asgn_type, _) () =
    let (field_type, _) =
      try
        Hashtbl.find targ_fields id
      with
      | Not_found -> raise error
    in
    check_type_match asgn_type field_type
  and
  check_type_match vtype atype =
    match (vtype, atype) with
    | (Sym.STBeantype vt, Sym.STBeantype at) -> match_beantype vt at
    | (Sym.STFieldStruct vfields, Sym.STFieldStruct afields) ->
        Hashtbl.fold (check_field vfields) afields ();
        Hashtbl.fold (check_field afields) vfields ()
    | _ -> raise error
  in
  let var_type = Sym.get_id_type symtbl callee_id param_id in
  check_type_match var_type arg_type

let check_asgn symtbl proc_id (lval, rval, pos) =
  let error expr = 
    let msg = 
      P.string_of_lval lval^" and "
      ^P.string_of_expr expr^ " have incompatible types"
    in
    Type_error (msg, pos)
  in
  let rec check_field_asgn field_tbl (id, sub_rval, pos) () =
    let (field_t_sym, _) =
      try
        Hashtbl.find field_tbl id
      with
      | Not_found -> raise (Sym.Undefined_field (id, pos))
    in
    match (field_t_sym, sub_rval) with
    | (Sym.STBeantype bt, AST.Rexpr expr) ->
        check_primitive_asgn symtbl proc_id (Sym.STBeantype bt) expr
    | (Sym.STFieldStruct subfields, AST.Rstruct sub_rvals) ->
      List.fold_right (check_field_asgn subfields) sub_rvals ()
    | (lval_type, AST.Rexpr expr) ->
        let expr_type = get_expr_type symtbl proc_id expr in
        if are_type_equivalent lval_type expr_type then
          ()
        else
          raise (error expr)
    | _ -> raise (Type_error
        ("Cannot assign a primitive type to a compound-typed lvalue", pos))
  in
  let (lval_t_sym, _) = Sym.get_lval_sym symtbl proc_id lval in
  match (lval_t_sym, rval) with
  | (Sym.STBeantype bt, AST.Rexpr expr) ->
      check_primitive_asgn symtbl proc_id (Sym.STBeantype bt) expr
  | (Sym.STFieldStruct fields, AST.Rstruct sub_rvals) ->
      List.fold_right (check_field_asgn fields) sub_rvals ()
  | (lval_type, AST.Rexpr expr) ->
      let expr_type = get_expr_type symtbl proc_id expr in
      if are_type_equivalent lval_type expr_type then
        ()
      else
        raise (error expr)
  | _ -> raise (Type_error
      ("Cannot assign a primitive type to a compound-typed lvalue", pos))


let check_read symtbl proc_id lval =
  if is_primitive symtbl proc_id lval then
    ()
  else
    raise (Read_struct (P.string_of_lval lval, AST.get_lval_pos lval))

let check_write symtbl proc_id wexpr =
  match wexpr with
  | AST.WString _    -> () (* Writing strings needs no checking *)
  | AST.WExpr   expr ->
      check_expr symtbl proc_id expr;
      match expr with
      | AST.Elval (lval, pos) ->
          if is_primitive symtbl proc_id lval then
            ()
          else
            raise (Write_struct (P.string_of_lval lval, pos))
      | _              -> ()

(* Check a procedure call *)
let check_pcall symtbl caller_id (callee_id, args, pos) =
  let proc =
    (* Make sure the call is valid -- i.e. the proc is defined*)
    let procs_tbl = symtbl.Sym.sym_procs in
    try Hashtbl.find procs_tbl callee_id
    with
    | Not_found ->
        raise (Sym.Undefined_proc (callee_id, pos))
  in
  let params = proc.Sym.proc_params in
  (* Make sure the call is the right arity *)
  if List.length args != List.length params then
    raise
    (Arity_mismatch
      (callee_id, pos))
  else
    (* Make sure the paramters are the right types and can be passed
     * by reference if they are required to be                       *)
    let go (param_id, arg) () =
      check_param_asgn symtbl caller_id callee_id param_id arg;
      check_pass_type symtbl caller_id callee_id param_id arg
    in
    List.fold_right go (List.combine params args) ()

(* Check a statement *)
let rec check_stmt symtbl proc_id stmt =
  let check_cond_expr expr =
    check_expr symtbl proc_id expr;
    let cond_not_bool =
      match get_expr_type symtbl proc_id expr with
      | Sym.STBeantype AST.TBool -> false
      | _                        -> true
    in
    if cond_not_bool then
      let pos = get_expr_pos expr in
      raise (Type_error
              ("Expression in conditional guard is not boolean", pos))
    else
      ()
  in
  let go stmt () = check_stmt symtbl proc_id stmt in
  match stmt with
  | AST.Assign   asgn          -> check_asgn  symtbl proc_id asgn
  | AST.Read     lval          -> check_read  symtbl proc_id lval
  | AST.Write    write         -> check_write symtbl proc_id write
  | AST.ProcCall pcall         -> check_pcall symtbl proc_id pcall
  | AST.While    (expr, stmts) ->
      check_cond_expr expr; List.fold_right go stmts ()
  | AST.If       (expr, stmts) ->
      check_cond_expr expr; List.fold_right go stmts ()
  | AST.IfElse   (expr, if_stmts, el_stmts) ->
      check_cond_expr expr;
      List.fold_right go if_stmts ();
      List.fold_right go el_stmts ()


(* Check the semantics of a single procedure definition *)
let check_proc symtbl (proc_id, _, (_, stmts), _) =
  let go stmt () = check_stmt symtbl proc_id stmt in
  List.fold_right go stmts ()

(* Check semantics, including declarations and types,
 * of a Bean program by running over the program body
 * with reference to the symbol table                 *)
let check_semantics symtbl program =
  check_has_main symtbl;
  (* Fold over all the procedures in the program to check them *)
  let go proc () = check_proc symtbl proc in
  let ps = program.AST.procs in
  List.fold_right go ps ()
============================================
src/bean_pprint.mli
16:38:20_Friday_20_May_2016
============================================
(* String representation of an expression *)
val string_of_expr : Bean_ast.expr -> string

val string_of_lval : Bean_ast.lvalue -> string

(* Pretty print a bean program from a bean AST type *)
val print_program : Format.formatter -> Bean_ast.t -> unit
