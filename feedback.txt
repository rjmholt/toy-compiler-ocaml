============================================
vis/rholt.out
14:59:46_Saturday_09_April_2016
============================================
COMP90045 project - Test of parser and pretty-printer
User:  rholt

--- Makefile found ---
--- Running Makefile ---
ocamlc  -c bean_ast.mli
ocamlopt  -g -c bean_ast.ml
ocamlyacc -v bean_parse.mly
ocamlc  -c bean_parse.mli
ocamlopt  -g -c bean_parse.ml
ocamllex bean_lex.mll
99 states, 5825 transitions, table size 23894 bytes
ocamlopt  -g -c bean_lex.ml
ocamlc  -c bean_pprint.mli
ocamlopt  -g -c bean_pprint.ml
ocamlopt  -g -c bean.ml
ocamlopt -g -o bean bean_ast.cmx bean_lex.cmx bean_parse.cmx bean_pprint.cmx bean.cmx

--- Succeeded ---

******************************************   Parsing lex01.bean:

Okay

******************************************   Parsing lex02.bean:

Okay

******************************************   Parsing lex03.bean:

Okay

******************************************   Parsing lex04.bean:

Okay

******************************************   Parsing syn01.bean:

Okay

******************************************   Parsing syn02.bean:

Okay

******************************************   Parsing prpr1.bean:

Okay

******************************************   Parsing prpr2.bean:

Okay

******************************************   Parsing prpr3.bean:

Okay

******************************************   Parsing prpr4.bean:

Okay

******************************************   Parsing prpr5.bean:

Okay

******************************************   Parsing prpr6.bean:

Okay

******************************************   Parsing bell.bean:

Okay

******************************************   Parsing fib.bean:

Okay

******************************************   Parsing gcd.bean:

Okay

******************************************   Parsing hail.bean:

Okay

******************************************   Parsing power.bean:

Okay

******************************************   Parsing stddev.bean:

Okay

******************************************   Parsing strange.bean:

Okay

******************************************   Parsing lex11.bad.bean:
proc main()
int x;
  x := @ ;
end
Result:
Unknown symbol "@" at line 3, column 9 in file "../data/lex11.bad.bean"

******************************************   Parsing lex12.bad.bean:
proc main()
int x;
int xyz_ab$;
bool z;
    x := 3;
    z := true;
    write z;
end
Result:
Unknown symbol "$" at line 3, column 12 in file "../data/lex12.bad.bean"

******************************************   Parsing lex13.bad.bean:
proc main()
    int int; int := 0;
end
Result:
Parse error at line 2, column 12 in file "../data/lex13.bad.bean"

******************************************   Parsing syn12.bad.bean:
proc main ()
    bool test; 
end

proc fib(int val n, ref int ref out)
    int f1;
    int f2;

    out := n;
}

Result:
Parse error at line 3, column 4 in file "../data/syn12.bad.bean"

******************************************   Parsing syn13.bad.bean:
proc main()
int x;
int y;
# Sequence of statements cannot be empty
end

Result:
Parse error at line 5, column 4 in file "../data/syn13.bad.bean"

******************************************   Parsing syn14.bad.bean:
proc main()
int m;
int n;
    read n;
    while n>1 do
        m := ( n;
        while m := m do
            if then
                n := n - 1;
                m := m - 1
                if true then m := m - 1; else n := 6*n + 4;
                fi
             fi
        od
    od
end
Result:
Parse error at line 6, column 18 in file "../data/syn14.bad.bean"

******************************************   Parsing syn15.bad.bean:
proc main()
    int x; x := 0; x := 1
end
Result:
Parse error at line 3, column 4 in file "../data/syn15.bad.bean"

******************************************   Parsing syn16.bad.bean:
proc main()
typedef {b: int} t

t a;
    t.b := 0;
end
Result:
Parse error at line 2, column 8 in file "../data/syn16.bad.bean"

******************************************   Parsing syn17.bad.bean:
proc main()
int n;
    n := 0;
end
    n := 1;
Result:
Parse error at line 5, column 6 in file "../data/syn17.bad.bean"

******************************************   Parsing syn18.bad.bean:
proc main()
int m;
int n;
    read m;
    write if m=n then
end
Result:
Parse error at line 5, column 13 in file "../data/syn18.bad.bean"

******************************************   Parsing syn19.bad.bean:
proc main(val int a, ref)
int m; read m;
end
Result:
Parse error at line 1, column 26 in file "../data/syn19.bad.bean"


--- End of testing for rholt ---\n

============================================
src/Makefile
14:59:44_Saturday_09_April_2016
============================================
TARGETS = bean
TARGETS_BYTE=$(TARGETS:%=%.byte)

MODULES = bean_ast bean_lex bean_parse bean_pprint
MLFILES = $(addsuffix .ml, $(MODULES))
CMOFILES = $(addsuffix .cmo, $(MODULES))
CMXFILES = $(addsuffix .cmx, $(MODULES))

ALLMODULES = $(MODULES) bean

OCAMLLEX = ocamllex
OCAMLYACC = ocamlyacc -v
OCAMLDEP = ocamldep

OCAMLFLAGS =

all : opt byte
byte: $(TARGETS_BYTE)
opt: $(TARGETS)

%.cmi: %.mli
	ocamlc $(OCAMLFLAGS) -c $<

%.cmo: %.ml
	ocamlc $(OCAMLFLAGS) -g -c $<

%.cmx: %.ml
	ocamlopt $(OCAMLOPTFLAGS) -g -c $<

%.ml: %.mll
	$(OCAMLLEX) $^

%.ml %.mli: %.mly
	$(OCAMLYACC) $^

bean.byte : $(CMOFILES) bean.cmo
	ocamlc -g -o $@ $^

bean : $(CMXFILES) bean.cmx
	ocamlopt -g -o $@ $^

clean :
	rm -f *.cmo *.cmi *.cmx *.o
	rm -f bean_lex.ml bean_parse.ml bean_parse.mli

clobber : clean
	rm -f $(TARGETS) $(TARGETS_BYTE)

.PHONY : clean clobber depend

# include depend
depend: bean_lex.ml bean_parse.ml
	$(OCAMLDEP) bean.ml bean.mli $(ALLMODULES:%=%.mli) $(ALLMODULES:%=%.ml) >Makefile.depend

-include Makefile.depend
============================================
src/bean_lex.mll
14:59:44_Saturday_09_April_2016
============================================
{
open Bean_parse

(* Define helpful error messages *)
exception Syntax_error of string
}

let digit  = ['0' - '9']
let alpha  = ['a' - 'z' 'A' - 'Z' '_']
let alnum  = alpha | digit | '\''
let digits = digit+
let ident  = alpha alnum*

rule token = parse
    [' ' '\t']            { token lexbuf }     (* skip blanks *)
  | '#'[^'\n']*           { token lexbuf }     (* ignore comments *)
  | '\n'                  { Lexing.new_line lexbuf ; token lexbuf }
  | '-'?['0'-'9']+ as lxm { INT_CONST(int_of_string lxm) }

  (* keywords *)
  | "bool"    { BOOL }
  | "int"     { INT }
  | "true"    { BOOL_CONST true }
  | "false"   { BOOL_CONST false }
  | "read"    { READ }
  | "write"   { WRITE }
  | "if"      { IF }
  | "then"    { THEN }
  | "else"    { ELSE }
  | "fi"      { FI }
  | "while"   { WHILE }
  | "do"      { DO }
  | "od"      { OD }
  | "val"     { VAL }
  | "ref"     { REF }
  | "proc"    { PROC }
  | "end"     { END }
  | "typedef" { TYPEDEF }
  | "and"     { AND }
  | "or"      { OR }
  | "not"     { NOT }

  (* Begin a string -- see second lex rule *)
  | '"'  { read_string (Buffer.create 20) lexbuf }
  | ','  { COMMA }
  | '.'  { DOT }
  | ":=" { ASSIGN }
  | '('  { LPAREN }
  | ')'  { RPAREN }
  | '{'  { LBRACE }
  | '}'  { RBRACE }

  (* Operators *)
  | '='  { EQ }
  | "!=" { NEQ }
  | '<'  { LT }
  | "<=" { LEQ }
  | '>'  { GT }
  | ">=" { GEQ }
  | '+'  { PLUS }
  | '-'  { MINUS }
  | '*'  { MUL }
  | '/'  { DIV }
  | ':'  { COLON }
  | ';'  { SEMICOLON }

  (* Idents have a low rule to not conflict with keywords *)
  | ident as lxm { IDENT lxm }
  | eof          { EOF }
  | _            { raise (Syntax_error
                          ("Unknown symbol \""^(Lexing.lexeme lexbuf)^"\"")) }

(* String parsing, with escaped characters*)
(* This is largely inspired by the JSON string parsing chapter in
 * Real World OCaml -- there aren't many different ways to do it  *)
and read_string buf =
  parse
  (* Terminate string *)
  | '"'           { STR_CONST (Buffer.contents buf) }
  (* Other characters *)
  | [^ '"' '\n']  { Buffer.add_string buf (Lexing.lexeme lexbuf);
                      read_string buf lexbuf }
  (* Weird characters are rejected *)
  | '\n' { raise (Syntax_error ("Illegal newline in string")) }
  | '\t' { raise (Syntax_error ("Illegal tab character in string")) }
  | _    { raise (Syntax_error
                ("Illegal string character: \""^(Lexing.lexeme lexbuf)^"\"")) }
  (* Programs can't terminate with an open string *)
  | eof  { raise (Syntax_error "End of file reached before string terminated") }
============================================
src/bean.ml
14:59:44_Saturday_09_April_2016
============================================
open Format
module P = Bean_parse
module L = Lexing

(* Argument parsing code *)
let infile_name = ref None

type compiler_mode = PrettyPrint | Compile
let mode = ref Compile

(* --------------------------------------------- *)
(*  Specification for command-line options       *)
(* --------------------------------------------- *)
let (speclist:(Arg.key * Arg.spec * Arg.doc) list) =
  ["-p",
     Arg.Unit(fun () -> mode := PrettyPrint),
     " Run the compiler in pretty-printer mode"
  ]

(* --------------------------------------------- *)
(*  Lexer/Parser error tracking functions        *)
(* --------------------------------------------- *)

(* Get's the lexer's position for error reporting *)
let get_lex_pos lexbuf =
  let pos = lexbuf.Lexing.lex_curr_p in
  let fname = pos.L.pos_fname in
  let line = pos.L.pos_lnum in
  let col = pos.L.pos_cnum - pos.L.pos_bol + 1 in
  (fname, line, col)

(* Set the lexer filename to the one passed in *)
let set_lex_file filename lexbuf =
  lexbuf.L.lex_curr_p <- { lexbuf.L.lex_curr_p with
                           L.pos_fname = filename }

(* MAIN FUNCTION *)
let main () =
  (* Parse the command-line arguments *)
  Arg.parse speclist
      (begin fun fname -> infile_name := Some fname end)
      "bean [-p] [bean source]" ;
  (* Open the input file *)
  let infile = match !infile_name with
  | None -> stdin
  | Some fname -> open_in fname in
  (* Initialize lexing buffer *)
  let lexbuf = Lexing.from_channel infile in
  let filename =
    match !infile_name with
    | None -> "\"stdin\""
    | Some fname -> String.concat "" ["\"";fname;"\""]
  in
  (* Assume bean doesn't link -- so the file being lexed
   * is always the one the compiler was called on...     *)
  set_lex_file filename lexbuf;
  (* Call the parser *)
  try
    (* Parsing happens here *)
    let prog = Bean_parse.program Bean_lex.token lexbuf in
    match !mode with
    | PrettyPrint ->
      Bean_pprint.print_program Format.std_formatter prog 
    | Compile -> ()
  with
  | Bean_lex.Syntax_error msg ->
      let (fname, ln, col) = get_lex_pos lexbuf in
      printf "%s at line %i, column %i in file %s\n"
         msg ln col fname
  | Parsing.Parse_error ->
      let (fname, ln, col) = get_lex_pos lexbuf in
      printf "%s at line %i, column %i in file %s\n"
        "Parse error" ln col fname

let _ = main ()
============================================
src/Makefile.depend
14:59:44_Saturday_09_April_2016
============================================
bean.cmo : bean_pprint.cmi bean_parse.cmi bean_lex.cmo
bean.cmx : bean_pprint.cmx bean_parse.cmx bean_lex.cmx
bean_ast.cmi :
bean_parse.cmi : bean_ast.cmi
bean_pprint.cmi : bean_ast.cmi
bean_ast.cmo : bean_ast.cmi
bean_ast.cmx : bean_ast.cmi
bean_lex.cmo : bean_parse.cmi
bean_lex.cmx : bean_parse.cmx
bean_parse.cmo : bean_ast.cmi bean_parse.cmi
bean_parse.cmx : bean_ast.cmx bean_parse.cmi
bean_pprint.cmo : bean_ast.cmi bean_pprint.cmi
bean_pprint.cmx : bean_ast.cmx bean_pprint.cmi
bean.cmo : bean_pprint.cmi bean_parse.cmi bean_lex.cmo
bean.cmx : bean_pprint.cmx bean_parse.cmx bean_lex.cmx
============================================
src/bean_pprint.ml
14:59:44_Saturday_09_April_2016
============================================
open Bean_ast
open Format

(* binary operators follow the following precedence order:
 *     arithmetic: [* /] > [+ -] > [= != < <= > >=]
 *     boolean:    [and or] > [= != < <= > >=]              *)
let isMulDiv     op = List.mem op [ Op_mul ; Op_div ]
let isAddSub     op = List.mem op [ Op_add ; Op_sub ]
let isAndOr      op = List.mem op [ Op_and ; Op_or  ]
let isComparator op = List.mem op [ Op_eq  ; Op_neq ;
                                    Op_lt  ; Op_leq ;
                                    Op_gt  ; Op_geq ]

(* True if the lower operation (subop) in the AST needs to
 * be printed with parens to preserve its precedence against
 * the higher operation (binop) in the printed bean program  *)
let needs_parens binop ?isRHS:(isRHS = false) subop =
  match binop with
  | Op_div -> not (isMulDiv subop) || isRHS
  | Op_mul -> not (isMulDiv subop)
  | Op_sub -> not (isMulDiv subop) && (not (isAddSub subop) || isRHS)
  | Op_add -> not (isMulDiv subop || isAddSub subop)
  | Op_eq | Op_neq | Op_gt | Op_geq | Op_lt | Op_leq -> isAndOr subop
  | Op_and -> subop = Op_or
  | Op_or  -> false

(* ---- STRING CONVERSION FUNCTIONS FOR AST LEAVES ---- *)

(* Lvalues look like:
 *   - LId -> "x"
 *   - LField -> "x.y.z"   *)
let rec string_of_lval lval =
  match lval with
  | LId     ident           -> ident
  | LField  (lval, ident)   -> String.concat "." [ident; string_of_lval lval]

(* Binary operator string representations *)
let string_of_binop binop =
  match binop with
  | Op_add  -> "+"
  | Op_sub  -> "-"
  | Op_mul  -> "*"
  | Op_div  -> "/"
  | Op_and  -> "and"
  | Op_or   -> "or"
  | Op_eq   -> "="
  | Op_neq  -> "!="
  | Op_lt   -> "<"
  | Op_leq  -> "<="
  | Op_gt   -> ">"
  | Op_geq  -> ">="

(* Unary operator string representations *)
let string_of_unop unop =
  match unop with
  | Op_minus  -> "-"
  | Op_not    -> "not"

(* Place parentheses around a string *)
let parenthesise str =
  String.concat str ["(";")"]

(* String representation of a unary operator expression *)
let rec string_of_unop_expr unop subexpr =
  let preserve_precedence_repr expr =
    match expr with
    | Ebinop _ -> parenthesise (string_of_expr expr)
    | _        -> string_of_expr expr
  in
  let sep = match unop with
  | Op_minus -> ""
  | Op_not   -> " "
  in
    String.concat sep [string_of_unop unop; preserve_precedence_repr subexpr]

(* String representation of a binary operator expression *)
and
string_of_binop_expr binop lexpr rexpr =
  let preserve_precedence_repr op ?isRHS:(isRHS=false) expr =
    match expr with
    | Ebinop (_, subop, _) ->
        if needs_parens op subop ~isRHS:isRHS
        then parenthesise (string_of_expr expr)
        else string_of_expr expr
    | _                    -> string_of_expr expr
  in
  String.concat " " [preserve_precedence_repr binop lexpr;
                     string_of_binop binop;
                     preserve_precedence_repr binop rexpr ~isRHS:true]
(* String representation of expressions.
 * Expressions can be lvals, unary operations, binary operations,
 * or literals. When they are complex, precedence matters and
 * parentheses are important, so parentheses are dealt with here   *)
and
string_of_expr expr =
  (* unary operators bind tightest -- all non-trivial subexpressions
   * need parentheses *)
  match expr with
  | Ebool  ebool                 -> string_of_bool ebool
  | Eint   eint                  -> string_of_int  eint
  | Elval  lval                  -> string_of_lval lval
  | Eunop  (unop, subexpr)       -> string_of_unop_expr unop subexpr
  | Ebinop (lexpr, binop, rexpr) -> string_of_binop_expr binop lexpr rexpr

(* Rval struct assignments look like:
 *     {x = true, y = {a = 8+10, b = true or v}}    *)
let rec string_of_struct_assign rstruct =
  let struct_body =
    String.concat ", " (List.map string_of_struct_entry rstruct)
  in
  String.concat struct_body ["{"; "}"]

(* Rval struct fields look like:
 *     x = 3 | y = true           *)
and
string_of_struct_entry (ident, rvalue) =
  String.concat " = " [ident; string_of_rval rvalue]

(* Rvals are either an expression or a struct init *)
and
string_of_rval rval =
  match rval with
  | Rexpr expr      -> string_of_expr expr
  | Rstruct rstruct -> string_of_struct_assign rstruct

(* Native bean type representations *)
let string_of_beantype bt =
  match bt with
  | TBool -> "bool"
  | TInt  -> "int"

(* Typespecs are either native bean types, user-defined, or structs (like in C):
 *   - bean types         -> "int" or "bool"
 *   - user-defined types -> <ident>
 *   - type specification -> {<field>, ...}                                 *)
let rec string_of_typespec ts =
  match ts with
  | TSBeantype bt        -> string_of_beantype bt
  | TSDefinedtype dt     -> dt
  | TSFieldStruct fields ->
      let fstrs = List.map string_of_field fields in
      let body = String.concat ", " fstrs in
      String.concat body ["{";"}"]

(* Each field looks like:
 *     <ident> : <typespec>  *)
and
string_of_field (ident, typespec) =
  String.concat " : " [ident; string_of_typespec typespec]

(* Declarations look like:
 *   <type> <ident>;       *)
let string_of_typedecl (id, beantype) =
    let bt_string = string_of_beantype beantype in
    String.concat "" [bt_string; " "; id; ";"]

(* Pass types are either "val" or "ref" *)
let string_of_pass pass_type =
  match pass_type with
  | Pval -> "val"
  | Pref -> "ref"

(* ---- PRINTING HELPER FUNCTIONS ---- *)

(* Print an ident of level n by printing 2*n spaces *)
let print_indent indent_level =
  for i = 1 to indent_level do
    printf "    "
  done

(* TYPEDEF PRINTING FUNCTIONS *)

(* Print a typedef:
 *   - print the "typedef" keyword
 *   - print the string representation of the typespec the typedef
 *     will represent
 *   - print the ident of the typedef                               *)
let print_typedef (typespec, ident) =
  printf "typedef ";
  printf "%s" (string_of_typespec typespec);
  printf " %s\n" ident

(* Print a typedef list by printing the first one, then the rest *)
let rec print_typedef_list typedefs =
  match typedefs with
  | []        -> printf "\n"
  | td :: tds -> print_typedef td; print_typedef_list tds

(* ---- DECLARATION PRINTING FUNCTIONS ---- *)

(* Print a variable declaration:
 *   - print the string representation of the typespec of the variable
 *   - print the ident of the variable                                  *)
let print_var_decl indent (ident, typespec) =
  print_indent indent;
  printf "%s %s;\n" (string_of_typespec typespec) ident

(* Print declarations by printing the first one, then the rest *)
let rec print_decl_list indent dlist =
  match dlist with
  | [decl]      -> print_var_decl indent decl
  | vdecl :: ds -> print_var_decl indent vdecl; print_decl_list indent ds
  | []          -> ()

(* ---- STATEMENT PRINTING FUNCTIONS ---- *)

(* Print an assignment statement:
 *   - print the lvalue being assigned to
 *   - print the ":=" operator
 *   - print the rvalue being assigned     *)
let print_assign indent lval rval =
  print_indent indent;
  printf "%s := %s;\n" (string_of_lval lval) (string_of_rval rval)

(* Print a read statement:
 *   - print "read"
 *   - print the string represenation of the lvalue *)
let print_read indent lval =
  print_indent indent;
  printf "read %s;\n" (string_of_lval lval)

(* Print write:
 *   - print "write"
 *   - if it's an expression:
 *       print the string representation of the expression
 *   - if it's a string:
 *       print the escaped string literal *)
let print_write indent writeable =
  print_indent indent;
  match writeable with
  | WExpr expr  -> printf "write %s;\n" (string_of_expr expr)
  | WString str ->
      printf "write %s;\n" (String.concat "" ["\"";str;"\""])

(* Print a procedure call:
 *   - print the procedure ident
 *   - print the expressions passed to the procedure in the call *)
let print_proc_call indent pname exprs =
  print_indent indent;
  printf "%s(%s);\n" pname (String.concat ", " (List.map string_of_expr exprs))

(* Print an if statement:
 *   - print "if"
 *   - print the boolean guard expression
 *   - print "then"
 *   - print body statements
 *   - if there are else body statements:
 *     + print "else"
 *     + print the else body statements
 *   - print "fi"                          *)
let rec print_if indent expr ?elses:(slist=[]) stmts =
  print_indent indent;
  printf "if %s then\n" (string_of_expr expr);
  print_stmt_list (indent+1) stmts;
  match slist with
  | [] -> print_indent indent ; printf "fi\n" ; ()
  | _ ->
    print_indent indent;
    printf "else\n";
    print_stmt_list (indent+1) slist;
  print_indent indent;
  printf "fi\n"

(* Print a while statement:
 *   - print "while"
 *   - print the boolean guard expression
 *   - print the body statements
 *   - print "od"                         *)
and
print_while indent expr stmts =
  print_indent indent;
  printf "while %s do\n" (string_of_expr expr);
  print_stmt_list (indent+1) stmts;
  print_indent indent;
  printf "od\n";

(* Print a statement list:
 *   - work out the type of the first statement
 *   - print it with the appropriate function
 *   - print the rest of the statements          *)
and
print_stmt_list indent stmt_list =
  let print_stmt stmt =
    match stmt with
    | Assign   (lval, rval)   -> print_assign indent lval rval
    | Read     lval           -> print_read indent lval
    | Write    writeable      -> print_write indent writeable
    | If       (expr, stmts)  -> print_if indent expr stmts
    | While    (expr, stmts)  -> print_while indent expr stmts
    | ProcCall (ident, exprs) -> print_proc_call indent ident exprs
    | IfElse (expr, if_stmts, else_stmts) ->
        print_if indent expr if_stmts ~elses:else_stmts
  in
  match stmt_list with
  | stmt :: slist   -> print_stmt stmt; print_stmt_list indent slist
  | []              -> ()

(* --- PROCEDURE PRINTING FUNCTIONS --- *)

(* Print a parameter:
 *   - print the pass type
 *   - print the typespec
 *   - print the parameter ident *)
let print_proc_param (pass_type, typespec, ident) =
  printf "%s " (string_of_pass pass_type);
  printf "%s " (string_of_typespec typespec);
  printf "%s"  ident

(* Print parameters by printing one, then a comma, then the rest *)
let rec print_proc_param_list param_list =
  match param_list with
  | []          -> ()
  | [param]     -> print_proc_param param
  | param :: ps -> print_proc_param param; printf ", ";
                   print_proc_param_list ps

(* Print a procedure:
 *   - print the "proc" keyword
 *   - print the parameters in the header
 *   - print the declarations in the body
 *   - print the statements in the body
 *   - print the "end" keyword             *)
let print_proc (ident, proc_params, proc_decls, body_stmts) =
  printf "proc %s(" ident;
  print_proc_param_list proc_params;
  printf ")\n";
  print_decl_list 1 proc_decls;
  printf "\n";
  print_stmt_list 1 body_stmts;
  printf "end"

(* Print procedures by printing one, then the rest *)
let rec print_proc_list plist =
  match plist with
  | []          -> ();
  | [proc]      -> print_proc proc; printf "\n"
  | proc :: ps  -> print_proc proc; printf "\n\n"; print_proc_list ps

(* --- BEAN PROGRAM PRINTING FUNCTION --- *)

(* Print a bean program by printing the typedefs then the procedures *)
let print_program fmt prog =
  print_typedef_list prog.typedefs;
  print_proc_list prog.procs
============================================
src/bean_ast.ml
14:59:44_Saturday_09_April_2016
============================================
(* Specification of an AST for bean *)
type ident = string

type beantype =
  | TBool
  | TInt

type definedtype = ident

(* Fields and typespecs are mutually recursive, as in:
 *     {x : int, y : {a : int, b : bool}}              *)
type field = (ident * typespec)

and
field_struct = field list

and
typespec =
  | TSBeantype    of beantype
  | TSDefinedtype of definedtype
  | TSFieldStruct of field_struct

type typedef = (typespec * ident)

type lvalue =
  | LId    of ident
  | LField of (lvalue * ident)

type binop =
  (* Arithmetic operations *)
  | Op_add | Op_sub | Op_mul | Op_div
  (* Integer comparator operations (int -> int -> bool) *)
  | Op_eq  | Op_neq | Op_lt  | Op_leq | Op_gt | Op_geq
  (* Boolean operations *)
  | Op_and | Op_or

type unop =
  | Op_minus
  | Op_not

type expr =
  | Ebool  of bool
  | Eint   of int
  | Elval  of lvalue
  | Ebinop of (expr * binop * expr)
  | Eunop  of (unop * expr)

type writeable =
  | WExpr   of expr
  | WString of string

(* A struct/field initialisation rvalue, like:
 *     var := {x = 3, y = {a = (7+3)*12, b = true}}   *)
type struct_init = (ident * rvalue) list

and rvalue =
  | Rexpr   of expr
  | Rstruct of struct_init

(* Proc parameter pass type:
 *   - "val" -> by value
 *   - "ref" -> by reference *)
type pass_type =
  | Pval
  | Pref

(* Parameters in a proc header *)
type proc_param = (pass_type * typespec * ident)

type stmt =
  | Assign   of (lvalue * rvalue)
  | Read     of lvalue
  | Write    of writeable
  | If       of (expr * stmt list)
  | IfElse   of (expr * stmt list * stmt list)
  | While    of (expr * stmt list)
  | ProcCall of (ident * expr list)

type decl = (ident * typespec)

type proc = (ident * proc_param list * decl list * stmt list)

type program = {
  typedefs : typedef list;
  procs    : proc    list
}

type t = program
============================================
src/bean_pprint.mli
14:59:44_Saturday_09_April_2016
============================================
val print_program : Format.formatter -> Bean_ast.t -> unit
============================================
src/bean_parse.mly
14:59:44_Saturday_09_April_2016
============================================
/* ocamlyacc parser for bean */
/* See the AST for better structural definitions of a bean program */
%{
open Bean_ast
%}

%token <bool>   BOOL_CONST
%token <int>    INT_CONST
%token <string> STR_CONST
%token <string> IDENT

%token BOOL INT
%token WRITE READ
%token ASSIGN
%token IF THEN ELSE FI
%token WHILE DO OD
%token PROC END
%token TYPEDEF
%token DOT
%token VAL REF
%token COMMA
%token LPAREN RPAREN
%token LBRACE RBRACE
%token EQ NEQ LT LEQ GT GEQ
%token AND OR NOT
%token PLUS MINUS MUL DIV
%token COLON
%token SEMICOLON
%token EOF

%left     OR
%left     AND 
%nonassoc UNOT
%nonassoc EQ NEQ LT LEQ GT GEQ
%left     PLUS MINUS
%left     MUL DIV
%nonassoc UMINUS

%type <Bean_ast.program> program

%start program
%%

program:
  typedefs procs { { typedefs = List.rev $1 ; procs = List.rev $2 } }

typedefs:
  | typedefs typedef { $2 :: $1 }
  |                  { [] }

beantype:
  | BOOL { TBool }
  | INT  { TInt  }

definedtype:
  IDENT { $1 }

typedef:
  TYPEDEF typespec IDENT { ($2, $3) }

typespec:
  | beantype             { TSBeantype    $1 }
  | definedtype          { TSDefinedtype $1 }
  | LBRACE fields RBRACE { TSFieldStruct (List.rev $2) }

fields:
  | fields COMMA field { $3 :: $1 }
  | field              { [$1] }

field:
  IDENT COLON typespec { ($1, $3) }

procs:
  | procs proc { $2 :: $1 }
  |            { [] }

proc:
  PROC IDENT LPAREN proc_params RPAREN decls stmts END { ($2,
                                                          List.rev $4,
                                                          List.rev $6,
                                                          $7) }

proc_params:
  | proc_params COMMA proc_param { $3 :: $1 }
  | proc_param                   { [$1] }
  |                              { [] }

proc_param:
  pass_type typespec IDENT { ($1, $2, $3) }

pass_type:
  | VAL { Pval }
  | REF { Pref }

decls:
  | decls decl { $2 :: $1 }
  |            { [] }

decl:
  typespec IDENT SEMICOLON { ($2, $1) }

/* Builds stmts in non-reverse, right-recursive order */
/* This is to eliminate a parser conflict error, but ideally
   the grammar could be restructured to eliminate it         */
stmts:
  | stmt stmts { $1 :: $2 }
  | stmt       { [$1] }

stmt:
  | stmt_body SEMICOLON              { $1 }
  | IF expr THEN stmts FI            { If ($2, $4) }
  | IF expr THEN stmts ELSE stmts FI { IfElse ($2, $4, $6) }
  | WHILE expr DO stmts OD           { While ($2, $4) }

stmt_body:
  | proc_call            { ProcCall $1 }
  | READ lvalue          { Read     $2 }
  | WRITE writeable      { Write    $2 }
  | lvalue ASSIGN rvalue { Assign ($1, $3) }

proc_call:
  IDENT LPAREN exprs RPAREN { ($1, List.rev $3) }

exprs:
  | exprs COMMA expr { $3 :: $1 }
  | expr             { [$1] }
  |                  { [] }

rvalue:
  | expr        { Rexpr   $1 }
  | struct_init { Rstruct $1 }

lvalue:
  | IDENT DOT lvalue { LField ($3, $1) }
  | IDENT            { LId $1 }

struct_init:
  LBRACE struct_assigns RBRACE { List.rev $2 }

struct_assigns:
  | struct_assigns COMMA struct_assign  { $3 :: $1 }
  | struct_assign                       { [$1] }

struct_assign:
  IDENT EQ rvalue { ($1, $3) }

expr:
  | literal            { $1 }
  | lvalue             { Elval $1 }
  | binop              { $1 }
  | unop               { $1 }
  | LPAREN expr RPAREN { $2 }

literal:
  | BOOL_CONST { Ebool $1 }
  | INT_CONST  { Eint  $1 }

binop:
  | expr PLUS  expr { Ebinop ($1, Op_add, $3) }
  | expr MINUS expr { Ebinop ($1, Op_sub, $3) }
  | expr MUL   expr { Ebinop ($1, Op_mul, $3) }
  | expr DIV   expr { Ebinop ($1, Op_div, $3) }
  | expr AND   expr { Ebinop ($1, Op_and, $3) }
  | expr OR    expr { Ebinop ($1, Op_or,  $3) }
  | expr EQ    expr { Ebinop ($1, Op_eq,  $3) }
  | expr NEQ   expr { Ebinop ($1, Op_neq, $3) }
  | expr LT    expr { Ebinop ($1, Op_lt,  $3) }
  | expr LEQ   expr { Ebinop ($1, Op_leq, $3) }
  | expr GT    expr { Ebinop ($1, Op_gt,  $3) }
  | expr GEQ   expr { Ebinop ($1, Op_geq, $3) }

unop:
  | MINUS expr %prec UMINUS { Eunop (Op_minus, $2) }
  | NOT   expr %prec UNOT   { Eunop (Op_not,   $2) }

 /* Deal with 'write' being able to print strings too */
writeable:
  | expr      { WExpr   $1 }
  | STR_CONST { WString $1 }
============================================
src/bean_ast.mli
14:59:44_Saturday_09_April_2016
============================================
(* Specification of an AST for bean *)
type ident = string
 
(* Define types and typedefs as mutually recusive so *)
(* typedefs can contain themselves                   *)
type beantype =
  | TBool
  | TInt

type definedtype = ident

type field = (ident * typespec)

and
field_struct = field list

and
typespec =
  | TSBeantype of beantype
  | TSDefinedtype of definedtype
  | TSFieldStruct of field_struct

type typedef = (typespec * ident)

type lvalue =
  | LId of ident
  | LField of (lvalue * ident)

type binop =
  (* Arithmetic operations *)
  | Op_add | Op_sub | Op_mul | Op_div
  (* Integer comparator operations (int -> int -> bool) *)
  | Op_eq | Op_neq | Op_lt | Op_leq | Op_gt | Op_geq
  (* Boolean operations *)
  | Op_and | Op_or

type unop =
  | Op_minus
  | Op_not

type expr =
  | Ebool of bool
  | Eint of int
  | Elval of lvalue
  | Ebinop of (expr * binop * expr)
  | Eunop of (unop * expr)

type writeable =
  | WExpr of expr
  | WString of string

(* Will need to AST elements with additional data.  *)
type struct_init = (ident * rvalue) list

and rvalue =
  | Rexpr of expr
  | Rstruct of struct_init

type pass_type =
  | Pval
  | Pref

type proc_param = (pass_type * typespec * ident)

type stmt = 
  | Assign of (lvalue * rvalue)
  | Read of lvalue
  | Write of writeable
  | If of (expr * stmt list)
  | IfElse of (expr * stmt list * stmt list)
  | While of (expr * stmt list)
  | ProcCall of (ident * expr list)

type decl = (ident * typespec)

type proc = (ident * proc_param list * decl list * stmt list)

type program = {
  typedefs : typedef list;
  procs : proc list
}
 
type t = program
