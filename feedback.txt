============================================
vis/rholt.out
10:09:42_Wednesday_06_April_2016
============================================
COMP90045 project - Test of parser and pretty-printer
User:  rholt

--- Makefile found ---
--- Running Makefile ---
ocamlc  -c bean_ast.mli
ocamlopt  -g -c bean_ast.ml
ocamlyacc -v bean_parse.mly
ocamlc  -c bean_parse.mli
ocamlopt  -g -c bean_parse.ml
ocamllex bean_lex.mll
104 states, 5294 transitions, table size 21800 bytes
ocamlopt  -g -c bean_lex.ml
ocamlc  -c bean_pprint.mli
ocamlopt  -g -c bean_pprint.ml
ocamlopt  -g -c bean.ml
ocamlopt -g -o bean bean_ast.cmx bean_lex.cmx bean_parse.cmx bean_pprint.cmx bean.cmx

--- Succeeded ---

******************************************   Parsing lex01.bean:

Mismatch:
3,7c3,6
<     int x;
< 
<     x := 2 + 1 - 1 * 1;
<     write x;
< end
---
>   int x;
>   x := (2 + 1) - 1 * 1;
>   write x;
> end
\ No newline at end of file

******************************************   Parsing lex02.bean:

Mismatch:
3,11c3,10
<     int x;
<     int y;
<     int z;
< 
<     read y;
<     x := y + 1;
<     z := x * x + y * y;
<     write z - 1;
< end
---
>   int x;
>   int y;
>   int z;
>   read y;
>   x := y + 1;
>   z := x * x + y * y;
>   write z - 1;
> end
\ No newline at end of file

******************************************   Parsing lex03.bean:

Mismatch:
3,10c3,9
<     int x;
<     int y;
<     int z;
< 
<     while 42 >= 42 do
<         x := 42;
<     od
< end
---
>   int x;
>   int y;
>   int z;
>   while 42 >= 42 do
>     x := 42;
>   od
> end
\ No newline at end of file

******************************************   Parsing lex04.bean:

Mismatch:
1c1
< typedef {a : int, b : int, c : bool} record
---
> typedef { a : int, b : int, c : bool } record
4,7c4,6
<     record r;
< 
<     r.c := false;
< end
---
>   record r;
>   r.c := false;
> end
\ No newline at end of file

******************************************   Parsing syn01.bean:

Mismatch:
3,8c3,7
<     int x;
< 
<     read x;
<     write (1 * (2 - 3) + 4 - 3) * 2 * -1;
<     write -1;
< end
---
>   int x;
>   read x;
>   write ((1 * (2 - 3) + 4) - 3) * 2 * -1;
>   write -1;
> end
\ No newline at end of file

******************************************   Parsing syn02.bean:

Mismatch:
4,6c4,5
< 
<     t1 := true;
< end
---
>   t1 := true;
> end
\ No newline at end of file

******************************************   Parsing prpr1.bean:

Mismatch:
3,6c3,11
<     bool a;
<     int m;
<     int n;
< 
---
>   bool a;
>   int m;
>   int n;
>   p(a);
>   m := n;
>   p(a);
>   n := (m + 9) - 1;
>   p(a);
>   if m = m then
8c13
<     m := n;
---
>   else
10c15,17
<     n := m + 9 - 1;
---
>   fi
>   if n = m then
>     n := m + 1;
12,23c19,22
<     if m = m then
<         p(a);
<     else
<         p(a);
<     fi
<     if n = m then
<         p(a);
<         n := m + 1;
<     else
<         p(a);
<     fi
< end
---
>   else
>     p(a);
>   fi
> end
\ No newline at end of file

******************************************   Parsing prpr2.bean:

Mismatch:
3,8c3,7
<     int x;
< 
<     x := -5 + 6;
<     x := -(5 - 2 - 1);
<     x := true and true or true and false;
< end
---
>   int x;
>   x := -5 + 6;
>   x := - ((5 - 2) - 1);
>   x := ((true and true) or true) and false;
> end
\ No newline at end of file

******************************************   Parsing prpr3.bean:

Mismatch:
3,6c3,5
<     int x;
< 
<     x := 6 + 3 * 2 + 4 * 5;
< end
---
>   int x;
>   x := (6 + 3 * 2) + 4 * 5;
> end
\ No newline at end of file

******************************************   Parsing prpr4.bean:

Mismatch:
3,19c3,15
<     int m;
<     int n;
< 
<     read n;
<     while n > 1 do
<         m := n;
<         while m > 0 do
<             if m > 0 then
<                 n := n - 1;
<                 m := m - 1;
<                 if m > 0 then
<                     m := m - 1;
<                 else
<                     n := 6 * n + 4;
<                 fi
<             fi
<         od
---
>   int m;
>   int n;
>   read n;
>   while n > 1 do
>     while m > 0 do
>       if m > 0 then
>         if m > 0 then
>           m := m - 1;
>         else
>           n := 6 * n + 4;
>         fi
>         m := m - 1;
>         n := n - 1;
21c17,19
< end
---
>     m := n;
>   od
> end
\ No newline at end of file

******************************************   Parsing prpr5.bean:

Mismatch:
3,6c3,6
<     bool x;
< 
<     x := false;
<     p(x, x);
---
>   bool x;
>   x := false;
>   p(x, x);
>   if x then
8,26c8,13
<         if x then
<             p(x, x);
<             if x then
<                 p(x, x);
<             else
<                 p(x, x);
<             fi
<         else
<             if x then
<                 p(x, x);
<             else
<                 while x do
<                     p(x, x);
<                     p(x, x);
<                 od
<                 p(x, x);
<             fi
<             p(x, x);
<         fi
---
>       if x then
>         p(x, x);
>       else
>         p(x, x);
>       fi
>       p(x, x);
27a15,19
>       p(x, x);
>       if x then
>         p(x, x);
>       else
>         p(x, x);
29,30c21,22
<             p(x, x);
<             p(x, x);
---
>           p(x, x);
>           p(x, x);
32,36c24
<         if x then
<             p(x, x);
<         else
<             p(x, x);
<         fi
---
>       fi
37a26,36
>   else
>     if x then
>       p(x, x);
>     else
>       p(x, x);
>     fi
>     while x do
>       p(x, x);
>       p(x, x);
>     od
>   fi
41,42c40
< 
<     write u + v;
---
>   write u + v;

******************************************   Parsing prpr6.bean:

Mismatch:
1,41c1
< 
< proc main()
< 
<     p(4);
< end
< 
< proc p()
<     int m;
<     int n;
<     int diff;
< 
<     read m;
<     read n;
<     while m != n do
<         diff := 0;
<         while m * n > 0 do
<             m := m - 1;
<             n := n - 1;
<             diff := diff + 1;
<         od
<         if m != 0 then
<             n := diff;
<         else
<             m := diff;
<         fi
<     od
<     write m;
< end
< 
< proc q()
<     bool x;
< 
<     x := true and true or true and false;
< end
< 
< proc r()
<     int x;
< 
<     x := 6;
<     s(x, x);
< end
---
> Parse error at line 2, column 8 in file "../data/prpr6.bean"

******************************************   Parsing bell.bean:

Mismatch:
1,29c1
< 
< proc main()
<     int n;
<     int result;
< 
<     write "Type integer n: ";
<     read n;
<     bell(n, 0, result);
<     write "Bell(n) is: ";
<     write result;
<     write "\n";
< end
< 
< proc bell(val int n, val int m, ref int out)
<     int res1;
<     int res2;
< 
<     if m = 0 then
<         if n = 0 then
<             out := 1;
<         else
<             bell(n - 1, n - 1, out);
<         fi
<     else
<         bell(n, m - 1, res1);
<         bell(n - 1, m - 1, res2);
<         out := res1 + res2;
<     fi
< end
---
> Parse error at line 7, column 14 in file "../data/bell.bean"

******************************************   Parsing fib.bean:

Mismatch:
1,24c1
< 
< proc main()
<     int n;
<     int m;
< 
<     write ">";
<     read n;
<     fib(n, m);
<     write m;
<     write "\n";
< end
< 
< proc fib(val int n, ref int out)
<     int f1;
<     int f2;
< 
<     if n <= 1 then
<         out := n;
<     else
<         fib(n - 2, f1);
<         fib(n - 1, f2);
<         out := f1 + f2;
<     fi
< end
---
> Parse error at line 24, column 16 in file "../data/fib.bean"

******************************************   Parsing gcd.bean:

Mismatch:
3,23c3,23
<     int x;
<     int y;
<     int temp;
<     int quotient;
<     int remainder;
< 
<     write "Input two positive integers: ";
<     read x;
<     read y;
<     write "\n";
<     if x < y then
<         temp := x;
<         x := y;
<         y := temp;
<     fi
<     write "The gcd of ";
<     write x;
<     write " and ";
<     write y;
<     write " is ";
<     quotient := x / y;
---
>   int x;
>   int y;
>   int temp;
>   int quotient;
>   int remainder;
>   write "Input two positive integers: ";
>   read x;
>   read y;
>   write "\n";
>   if x < y then
>     y := temp;
>     x := y;
>     temp := x;
>   write "The gcd of ";
>   write x;
>   write " and ";
>   write y;
>   write " is ";
>   quotient := x / y;
>   remainder := x - quotient * y;
>   while remainder > 0 do
25,33c25,31
<     while remainder > 0 do
<         x := y;
<         y := remainder;
<         quotient := x / y;
<         remainder := x - quotient * y;
<     od
<     write y;
<     write "\n";
< end
---
>     quotient := x / y;
>     y := remainder;
>     x := y;
>   od
>   write y;
>   write "\n";
> end
\ No newline at end of file

******************************************   Parsing hail.bean:

Mismatch:
1,30c1
< 
< proc main()
<     int n;
<     int result;
< 
<     n := 1;
<     while n < 21 do
<         hail(n, result);
<         write result;
<         write " ";
<         n := n + 1;
<     od
<     write "\n";
< end
< 
< proc hail(val int in, ref int out)
<     int count;
< 
<     count := 1;
<     if in = 1 then
<         out := count;
<     else
<         if in / 2 * 2 = in then
<             hail(in / 2, count);
<         else
<             hail(3 * in + 1, count);
<         fi
<         out := count + 1;
<     fi
< end
---
> Parse error at line 25, column 21 in file "../data/hail.bean"

******************************************   Parsing power.bean:

Mismatch:
1,30c1
< 
< proc main()
<     float x;
<     float result;
<     int n;
< 
<     write "Float x: ";
<     read x;
<     write "Positive integer n: ";
<     read n;
<     power(x, n, result);
<     write "x^n is: ";
<     write result;
<     write "\n";
< end
< 
< proc power(val float x, val int n, ref float out)
<     float res;
< 
<     if n = 1 then
<         out := x;
<     else
<         power(x * x, n / 2, res);
<         if 2 * n / 2 = n then
<             out := res;
<         else
<             out := x * res;
<         fi
<     fi
< end
---
> Parse error at line 21, column 13 in file "../data/power.bean"

******************************************   Parsing stddev.bean:

Mismatch:
3,11c3,12
<     int x;
<     int sum;
<     int sumsq;
<     int mean;
<     int count;
<     int done;
< 
<     write "Type a list of integers, ending with a negative number\n";
<     read x;
---
>   int x;
>   int sum;
>   int sumsq;
>   int mean;
>   int count;
>   int done;
>   write "Type a list of integers, ending with a negative number\n";
>   read x;
>   done := x < 0;
>   while not done do
13,27c14,26
<     while not done do
<         count := count + 1;
<         sum := sum + x;
<         sumsq := sumsq + x * x;
<         read x;
<         done := x < 0;
<     od
<     mean := sum / count;
<     write "The mean is ";
<     write mean;
<     write "\n";
<     write "The variance is ";
<     write sumsq / count - mean * mean;
<     write "\n";
< end
---
>     read x;
>     sumsq := sumsq + x * x;
>     sum := sum + x;
>     count := count + 1;
>   od
>   mean := sum / count;
>   write "The mean is ";
>   write mean;
>   write "\n";
>   write "The variance is ";
>   write sumsq / count - mean * mean;
>   write "\n";
> end
\ No newline at end of file

******************************************   Parsing strange.bean:

Mismatch:
1,2c1,2
< typedef {f1 : int, f2 : {g1 : bool, g2 : bool}} a_record
< typedef {used : bool, rec : a_record} b_record
---
> typedef { f1 : int, f2 : { g1 : bool, g2 : bool } } a_record
> typedef { used : bool, rec : a_record } b_record
5,10c5,9
<     int n;
<     bool y;
<     a_record z;
< 
<     z.f1 := 42;
<     z.f2 := {g2 = true, g1 = false};
---
>   int n;
>   bool y;
>   a_record z;
>   z.f1 := 42;
>   z.f2 := {g2 = true, g1 = false};
14,15c13
< 
<     i := 6 * i + 4;
---
>   i := 6 * i + 4;
19,36c17,30
<     int m;
<     int n;
< 
<     read n;
<     while n > 1 do
<         m := n;
<         while m > 0 do
<             if m > 0 then
<                 n := n - 1;
<                 m := m - 1;
<                 if m = 0 then
<                     p(n);
<                 fi
<             else
<                 m := n - m;
<                 m := m - 1;
<             fi
<         od
---
>   int m;
>   int n;
>   read n;
>   while n > 1 do
>     while m > 0 do
>       if m > 0 then
>         if m = 0 then
>           p(n);
>         m := m - 1;
>         n := n - 1;
>       else
>         m := m - 1;
>         m := n - m;
>       fi
37a32,33
>     m := n;
>   od
38a35
> 

******************************************   Parsing lex11.bad.bean:
proc main()
int x;
  x := @ ;
end
Result:
Unknown symbol "@" at line 3, column 9 in file "../data/lex11.bad.bean"

******************************************   Parsing lex12.bad.bean:
proc main()
int x;
int xyz_ab$;
bool z;
    x := 3;
    z := true;
    write z;
end
Result:
Unknown symbol "$" at line 3, column 12 in file "../data/lex12.bad.bean"

******************************************   Parsing lex13.bad.bean:
proc main()
    int int; int := 0;
end
Result:
Parse error at line 2, column 12 in file "../data/lex13.bad.bean"

******************************************   Parsing syn12.bad.bean:
proc main ()
    bool test; 
end

proc fib(int val n, ref int ref out)
    int f1;
    int f2;

    out := n;
}

Result:
Parse error at line 5, column 13 in file "../data/syn12.bad.bean"

******************************************   Parsing syn13.bad.bean:
proc main()
int x;
int y;
# Sequence of statements cannot be empty
end

Result:

proc main()
  int x;
  int y;
end
******************************************   Parsing syn14.bad.bean:
proc main()
int m;
int n;
    read n;
    while n>1 do
        m := ( n;
        while m := m do
            if then
                n := n - 1;
                m := m - 1
                if true then m := m - 1; else n := 6*n + 4;
                fi
             fi
        od
    od
end
Result:
Parse error at line 6, column 18 in file "../data/syn14.bad.bean"

******************************************   Parsing syn15.bad.bean:
proc main()
    int x; x := 0; x := 1
end
Result:
Parse error at line 3, column 4 in file "../data/syn15.bad.bean"

******************************************   Parsing syn16.bad.bean:
proc main()
typedef {b: int} t

t a;
    t.b := 0;
end
Result:
Parse error at line 2, column 8 in file "../data/syn16.bad.bean"

******************************************   Parsing syn17.bad.bean:
proc main()
int n;
    n := 0;
end
    n := 1;
Result:
Parse error at line 5, column 6 in file "../data/syn17.bad.bean"

******************************************   Parsing syn18.bad.bean:
proc main()
int m;
int n;
    read m;
    write if m=n then
end
Result:
Parse error at line 5, column 13 in file "../data/syn18.bad.bean"

******************************************   Parsing syn19.bad.bean:
proc main(val int a, ref)
int m; read m;
end
Result:
Parse error at line 1, column 26 in file "../data/syn19.bad.bean"


--- End of testing for rholt ---\n

============================================
src/bean_ast.mli
10:09:41_Wednesday_06_April_2016
============================================
(* Specification of an AST for bean *)
type ident = string
 
(* Define types and typedefs as mutually recusive so *)
(* typedefs can contain themselves                   *)
type beantype =
  | TBool
  | TInt
  | TNamedTypedef of ident
  | TAnonTypedef of fielddecl list

and
fielddecl = (ident * beantype)

and
typedefbody =
  | TDStruct of fielddecl list
  | TDAlias of beantype

and
typedef = (typedefbody * ident)

type lvalue =
  | LId of ident
  | LField of (lvalue * ident)

type binop =
  (* Arithmetic operations *)
  | Op_add | Op_sub | Op_mul | Op_div
  (* Integer comparator operations (int -> int -> bool) *)
  | Op_eq | Op_neq | Op_lt | Op_leq | Op_gt | Op_geq
  (* Boolean operations *)
  | Op_and | Op_or

type unop =
  | Op_minus
  | Op_not

type expr =
  | Ebool of bool
  | Eint of int
  | Elval of lvalue
  | Ebinop of (expr * binop * expr)
  | Eunop of (unop * expr)

type writeable =
  | WExpr of expr
  | WString of string

(* Will need to AST elements with additional data.  *)
type struct_init = (ident * rvalue) list

and rvalue =
  | Rexpr of expr
  | Rstruct of struct_init

type pass_type =
  | Pval
  | Pref

type proc_head = (pass_type * beantype * ident)

type stmt = 
  | Assign of (lvalue * rvalue)
  | Read of lvalue
  | Write of writeable
  | If of (expr * stmt list)
  | IfElse of (expr * stmt list * stmt list)
  | While of (expr * stmt list)
  | ProcCall of (ident * lvalue list)

type decl = (ident * beantype)

type proc = (ident * proc_head list * decl list * stmt list)

type program = {
  typedefs : typedef list;
  procs : proc list
}
 
type t = program
============================================
src/bean_parse.mly
10:09:41_Wednesday_06_April_2016
============================================
/* ocamlyacc parser for bean */
%{
open Bean_ast
%}

%token <bool> BOOL_CONST
%token <int> INT_CONST
%token <string> STR_CONST
%token <string> IDENT
%token BOOL INT
%token WRITE READ
%token ASSIGN
%token IF THEN ELSE FI
%token WHILE DO OD
%token PROC END
%token TYPEDEF
%token DOT
%token VAL REF
%token COMMA
%token LPAREN RPAREN
%token LBRACE RBRACE
%token EQ NEQ LT LEQ GT GEQ
%token AND OR NOT
%token PLUS MINUS MUL DIV
%token COLON
%token SEMICOLON
%token EOF

%nonassoc EQ NEQ LT LEQ GT GEQ
%left PLUS MINUS
%left MUL DIV
%left AND OR
%nonassoc UMINUS
%nonassoc UNOT

%type <Bean_ast.program> program

%start program
%%

program:
  typedefs procs { { typedefs = List.rev $1; procs = List.rev $2 } }

beantype:
  | BOOL { TBool }
  | INT { TInt }
  | IDENT { TNamedTypedef $1 }

typedefs:
  | typedefs typedef { $2 :: $1 }
  | { [] }

typedef:
  TYPEDEF typedefbody IDENT { ($2, $3) }
  
typedefbody:
  | beantype { TDAlias $1 }
  | tdfields { TDStruct $1 }

tdfields :
  LBRACE fielddecls RBRACE { List.rev $2 }

fielddecls:
  | fielddecls COMMA fielddecl { $3 :: $1 }
  | fielddecl { [$1] }
  | { [] }

fieldtype:
  | beantype { $1 }
  | tdfields { TAnonTypedef $1 }

fielddecl:
  IDENT COLON fieldtype { ($1, $3) }

proc:
  PROC IDENT LPAREN proc_heads RPAREN decls stmts END { ($2,
                                                         List.rev $4,
                                                         List.rev $6,
                                                         $7) }

procs:
  | procs proc { $2 :: $1 }
  | { [] }

proc_heads:
  | proc_heads COMMA proc_head { $3 :: $1 }
  | proc_head { [$1] }
  | { [] }

proc_head:
  pass_type beantype IDENT { ($1, $2, $3) }

pass_type:
  | VAL { Pval }
  | REF { Pref }

decls:
  | decls decl { $2 :: $1 }
  | { [] }

decl:
  beantype IDENT SEMICOLON { ($2, $1) }

/* Builds stmts in non-reverse, right-recursive order */
stmts:
  | stmt stmts { $1 :: $2 }
  | { [] }

stmt:
  | stmt_body SEMICOLON { $1 }
  | IF expr THEN stmts FI { If ($2, List.rev $4) }
  | IF expr THEN stmts ELSE stmts FI { IfElse ($2, List.rev $4, List.rev $6) }
  | WHILE expr DO stmts OD { While ($2, List.rev $4) }

stmt_body:
  | proc_call { ProcCall $1 }
  | READ lvalue { Read $2 }
  | WRITE writeable { Write $2 }
  | lvalue ASSIGN rvalue { Assign ($1, $3) }

proc_call:
  IDENT LPAREN lvaluelist RPAREN { ($1, List.rev $3) }

rvalue:
  | expr { Rexpr $1 }
  | struct_init { Rstruct $1 }

lvalue:
  | IDENT DOT lvalue { LField ($3, $1) }
  | IDENT { LId $1 }

lvaluelist:
  | lvaluelist COMMA lvalue { $3 :: $1 }
  | lvalue { [$1] }
  | { [] }

struct_init:
  LBRACE struct_assigns RBRACE { List.rev $2 }

struct_assigns:
  | struct_assigns COMMA struct_assign { $3 :: $1 }
  | struct_assign { [$1] }

struct_assign:
  IDENT EQ rvalue { ($1, $3) }

expr:
  | BOOL_CONST { Ebool $1 }
  | INT_CONST { Eint $1 }
  | lvalue { Elval $1 }
  /* Binary operators */
  | expr PLUS expr { Ebinop ($1, Op_add, $3) }
  | expr MINUS expr { Ebinop ($1, Op_sub, $3) }
  | expr MUL expr { Ebinop ($1, Op_mul, $3) }
  | expr DIV expr { Ebinop ($1, Op_div, $3) }
  | expr AND expr { Ebinop ($1, Op_and, $3) }
  | expr OR expr { Ebinop ($1, Op_or, $3) }
  | expr EQ expr { Ebinop ($1, Op_eq, $3) }
  | expr NEQ expr { Ebinop ($1, Op_neq, $3) }
  | expr LT expr { Ebinop ($1, Op_lt, $3) }
  | expr LEQ expr { Ebinop ($1, Op_leq, $3) }
  | expr GT expr { Ebinop ($1, Op_gt, $3) }
  | expr GEQ expr { Ebinop ($1, Op_geq, $3) }
  | MINUS expr %prec UMINUS { Eunop (Op_minus, $2) }
  | NOT expr %prec UNOT { Eunop (Op_not, $2) }
  | LPAREN expr RPAREN { $2 }

 /* Deal with 'write' being able to print strings too */
writeable:
  | expr { WExpr $1 }
  | STR_CONST  { WString $1 }
============================================
src/bean_ast.ml
10:09:41_Wednesday_06_April_2016
============================================
(* Specification of an AST for bean *)
type ident = string
 
(* Define types and typedefs as mutually recusive so *)
(* typedefs can contain themselves                   *)
type beantype =
  | TBool
  | TInt
  | TNamedTypedef of ident
  | TAnonTypedef of fielddecl list

and
fielddecl = (ident * beantype)

and
typedefbody =
  | TDStruct of fielddecl list
  | TDAlias of beantype

and
typedef = (typedefbody * ident)

type lvalue =
  | LId of ident
  | LField of (lvalue * ident)

type binop =
  (* Arithmetic operations *)
  | Op_add | Op_sub | Op_mul | Op_div
  (* Integer comparator operations (int -> int -> bool) *)
  | Op_eq | Op_neq | Op_lt | Op_leq | Op_gt | Op_geq
  (* Boolean operations *)
  | Op_and | Op_or

type unop =
  | Op_minus
  | Op_not

type expr =
  | Ebool of bool
  | Eint of int
  | Elval of lvalue
  | Ebinop of (expr * binop * expr)
  | Eunop of (unop * expr)

type writeable =
  | WExpr of expr
  | WString of string

(* Will need to AST elements with additional data.  *)
type struct_init = (ident * rvalue) list

and rvalue =
  | Rexpr of expr
  | Rstruct of struct_init

type pass_type =
  | Pval
  | Pref

type proc_head = (pass_type * beantype * ident)

type stmt = 
  | Assign of (lvalue * rvalue)
  | Read of lvalue
  | Write of writeable
  | If of (expr * stmt list)
  | IfElse of (expr * stmt list * stmt list)
  | While of (expr * stmt list)
  | ProcCall of (ident * lvalue list)

type decl = (ident * beantype)

type proc = (ident * proc_head list * decl list * stmt list)

type program = {
  typedefs : typedef list;
  procs : proc list
}
 
type t = program
============================================
src/Makefile.depend
10:09:41_Wednesday_06_April_2016
============================================
bean.cmo : bean_pprint.cmi bean_parse.cmi bean_lex.cmo
bean.cmx : bean_pprint.cmx bean_parse.cmx bean_lex.cmx
bean_ast.cmi :
bean_parse.cmi : bean_ast.cmi
bean_pprint.cmi : bean_ast.cmi
bean_ast.cmo : bean_ast.cmi
bean_ast.cmx : bean_ast.cmi
bean_lex.cmo : bean_parse.cmi
bean_lex.cmx : bean_parse.cmx
bean_parse.cmo : bean_ast.cmi bean_parse.cmi
bean_parse.cmx : bean_ast.cmx bean_parse.cmi
bean_pprint.cmo : bean_ast.cmi bean_pprint.cmi
bean_pprint.cmx : bean_ast.cmx bean_pprint.cmi
bean.cmo : bean_pprint.cmi bean_parse.cmi bean_lex.cmo
bean.cmx : bean_pprint.cmx bean_parse.cmx bean_lex.cmx
============================================
src/bean.ml
10:09:41_Wednesday_06_April_2016
============================================
open Format
module P = Bean_parse
module L = Lexing

(* Argument parsing code *)
let infile_name = ref None

type compiler_mode = PrettyPrint | Compile
let mode = ref Compile

(* --------------------------------------------- *)
(*  Specification for command-line options       *)
(* --------------------------------------------- *)
let (speclist:(Arg.key * Arg.spec * Arg.doc) list) =
  ["-p",
     Arg.Unit(fun () -> mode := PrettyPrint),
     " Run the compiler in pretty-printer mode"
  ]

(* --------------------------------------------- *)
(*  Lexer/Parser error tracking functions        *)
(* --------------------------------------------- *)

let get_lex_pos lexbuf =
  let pos = lexbuf.Lexing.lex_curr_p in
  let fname = pos.L.pos_fname in
  let line = pos.L.pos_lnum in
  let col = pos.L.pos_cnum - pos.L.pos_bol + 1 in
  (fname, line, col)

let set_lex_file filename lexbuf =
  lexbuf.L.lex_curr_p <- { lexbuf.L.lex_curr_p with
                           L.pos_fname = filename }

let main () =
  (* Parse the command-line arguments *)
  Arg.parse speclist
      (begin fun fname -> infile_name := Some fname end)
      "bean [-p] [bean source]" ;
  (* Open the input file *)
  let infile = match !infile_name with
  | None -> stdin
  | Some fname -> open_in fname in
  (* Initialize lexing buffer *)
  let lexbuf = Lexing.from_channel infile in
  let filename =
    match !infile_name with
    | None -> "\"stdin\""
    | Some fname -> String.concat "" ["\"";fname;"\""]
  in
  set_lex_file filename lexbuf;
  (* Call the parser *)
  try
    let prog = Bean_parse.program Bean_lex.token lexbuf in
    match !mode with
    | PrettyPrint ->
      Bean_pprint.print_program Format.std_formatter prog 
    | Compile -> ()
  with
  | Bean_lex.Syntax_error msg ->
      let (fname, ln, col) = get_lex_pos lexbuf in
      printf "%s at line %i, column %i in file %s\n"
         msg ln col fname
  | e ->
      let (fname, ln, col) = get_lex_pos lexbuf in
      printf "%s at line %i, column %i in file %s\n"
        "Parse error" ln col fname

let _ = main ()
============================================
src/bean_pprint.mli
10:09:41_Wednesday_06_April_2016
============================================
val print_program : Format.formatter -> Bean_ast.t -> unit
============================================
src/Makefile
10:09:41_Wednesday_06_April_2016
============================================
TARGETS = bean
TARGETS_BYTE=$(TARGETS:%=%.byte)

MODULES = bean_ast bean_lex bean_parse bean_pprint
MLFILES = $(addsuffix .ml, $(MODULES))
CMOFILES = $(addsuffix .cmo, $(MODULES))
CMXFILES = $(addsuffix .cmx, $(MODULES))

ALLMODULES = $(MODULES) bean

OCAMLLEX = ocamllex
OCAMLYACC = ocamlyacc -v
OCAMLDEP = ocamldep

OCAMLFLAGS =

all : opt byte
byte: $(TARGETS_BYTE)
opt: $(TARGETS)

%.cmi: %.mli
	ocamlc $(OCAMLFLAGS) -c $<

%.cmo: %.ml
	ocamlc $(OCAMLFLAGS) -g -c $<

%.cmx: %.ml
	ocamlopt $(OCAMLOPTFLAGS) -g -c $<

%.ml: %.mll
	$(OCAMLLEX) $^

%.ml %.mli: %.mly
	$(OCAMLYACC) $^

bean.byte : $(CMOFILES) bean.cmo
	ocamlc -g -o $@ $^

bean : $(CMXFILES) bean.cmx
	ocamlopt -g -o $@ $^

clean :
	rm -f *.cmo *.cmi *.cmx *.o
	rm -f bean_lex.ml bean_parse.ml bean_parse.mli

clobber : clean
	rm -f $(TARGETS) $(TARGETS_BYTE)

.PHONY : clean clobber depend

# include depend
depend: bean_lex.ml bean_parse.ml
	$(OCAMLDEP) bean.ml bean.mli $(ALLMODULES:%=%.mli) $(ALLMODULES:%=%.ml) >Makefile.depend

-include Makefile.depend
============================================
src/bean_lex.mll
10:09:41_Wednesday_06_April_2016
============================================
{
open Bean_parse

(* Define helpful error messages *)
exception Syntax_error of string
}

let digit = ['0' - '9']
let alpha = ['a' - 'z' 'A' - 'Z' '_']
let alnum = alpha | digit
let digits = digit+
let ident = alpha alnum*
rule token = parse
    [' ' '\t']    { token lexbuf }     (* skip blanks *)
  | '#'[^'\n']*   { token lexbuf }     (* ignore comments *)
  | '\n'          { Lexing.new_line lexbuf ; token lexbuf }
  | '-'?['0'-'9']+ as lxm { INT_CONST(int_of_string lxm) }
  (* keywords *)
  | "bool" { BOOL }
  | "int" { INT }
  | "true" { BOOL_CONST true }
  | "false" { BOOL_CONST false }
  | "read" { READ }
  | "write" { WRITE }
  | "if" { IF }
  | "then" { THEN }
  | "else" { ELSE }
  | "fi" { FI }
  | "while" { WHILE }
  | "do" { DO }
  | "od" { OD }
  | "val" { VAL }
  | "ref" { REF }
  | "proc" { PROC }
  | "end" { END }
  | "typedef" { TYPEDEF }
  | '"' { read_string (Buffer.create 20) lexbuf }
  | ',' { COMMA }
  | '.' { DOT }
  | ":=" { ASSIGN }
  | '(' { LPAREN }
  | ')' { RPAREN }
  | '{' { LBRACE }
  | '}' { RBRACE }
  | '=' { EQ }
  | "!=" { NEQ }
  | '<' { LT }
  | "<=" { LEQ }
  | '>' { GT }
  | ">=" { GEQ }
  | '+' { PLUS }
  | '-' { MINUS }
  | '*' { MUL }
  | '/' { DIV }
  | "and" { AND }
  | "or" { OR }
  | "not" { NOT }
  | ':' { COLON }
  | ';' { SEMICOLON }
  | ident as lxm { IDENT lxm }
  | _ { raise (Syntax_error 
          ("Unknown symbol \""^(Lexing.lexeme lexbuf)^"\"")) }
  | eof { EOF }

and read_string buf =
  parse
  | '"' { STR_CONST (Buffer.contents buf) }
  | '\\' '\\' { Buffer.add_char buf '\\'; read_string buf lexbuf }
  | '\\' '/' { Buffer.add_char buf '/'; read_string buf lexbuf }
  | '\\' 'n' { Buffer.add_char buf '\n'; read_string buf lexbuf }
  | '\\' 'r' { Buffer.add_char buf '\r'; read_string buf lexbuf }
  | '\\' 't' { Buffer.add_char buf '\t'; read_string buf lexbuf }
  | [^ '"' '\\'] { Buffer.add_string buf (Lexing.lexeme lexbuf);
                   read_string buf lexbuf }
  | _ { raise (Syntax_error
                ("Illegal string character: \""^(Lexing.lexeme lexbuf)^"\"")) }
  | eof { raise (Syntax_error "End of file reached before string terminated") }
============================================
src/bean_pprint.ml
10:09:41_Wednesday_06_April_2016
============================================
open Bean_ast
open Format

(* binary operators follow the following precedence order:
 *     arithmetic: [* /] > [+ -] > [= != < <= > >=]
 *     boolean:    [and or] > [= != < <= > >=]              *)
let isMulDiv op = List.mem op [Op_mul; Op_div]
let isAddSub op = List.mem op [Op_and; Op_sub]
let isAndOr op = List.mem op [Op_and;Op_or]
let isComparator op = List.mem op [Op_eq;Op_neq;Op_lt;Op_leq;Op_gt;Op_geq]

(* True if binop1 is higher precedence than binop2 *)
let isHigherPrecedence binop1 binop2 =
  match binop1 with
  | Op_mul | Op_div | Op_and | Op_or -> not (isMulDiv binop2)
  | Op_add | Op_sub                  -> not (isMulDiv binop2)
                                        || isComparator binop2
  | _                                -> false

(* ---- STRING CONVERSION FUNCTIONS FOR AST LEAVES ---- *)
let rec string_of_lval lval =
  match lval with
  | LId     ident           -> ident
  | LField  (lval, ident)   -> String.concat "." [ident; string_of_lval lval]

let string_of_binop binop =
  match binop with
  | Op_add  -> "+"
  | Op_sub  -> "-"
  | Op_mul  -> "*"
  | Op_div  -> "/"
  | Op_and  -> "and"
  | Op_or   -> "or"
  | Op_eq   -> "="
  | Op_neq  -> "!="
  | Op_lt   -> "<"
  | Op_leq  -> "<="
  | Op_gt   -> ">"
  | Op_geq  -> ">="

let string_of_unop unop =
  match unop with
  | Op_minus  -> "-"
  | Op_not    -> "not"

let rec string_of_expr expr =
  (* unary operators bind tightest -- all non-trivial subexpressions
   * need parentheses *)
  let parenthesise expr = String.concat "" ["("; string_of_expr expr; ")"] in
  let unop_subexpr subexpr =
    match subexpr with
    | Ebinop _ -> parenthesise subexpr
    | Eunop _  -> parenthesise subexpr
    | _        -> string_of_expr subexpr
  in
  let binop_subexpr op subexpr =
    match subexpr with
    | Ebinop (_, binop, _)  -> if isHigherPrecedence op binop
      then parenthesise subexpr else string_of_expr subexpr
    | _                     -> string_of_expr subexpr
  in
  match expr with
  | Ebool   ebool                -> string_of_bool ebool
  | Eint    eint                 -> string_of_int eint
  | Elval   lval                 -> string_of_lval lval
  | Eunop (unop, expr)           ->
      String.concat " " [string_of_unop unop; unop_subexpr expr]
  | Ebinop (lexpr, binop, rexpr) ->
      String.concat " " [binop_subexpr binop lexpr;
                         string_of_binop binop;
                         binop_subexpr binop rexpr]

let rec string_of_struct_assign rstruct =
  let struct_body =
    String.concat ", " (List.map string_of_struct_entry rstruct)
  in
  String.concat struct_body ["{"; "}"]

and string_of_struct_entry (ident, rvalue) =
  String.concat " = " [ident; string_of_rval rvalue]

and
string_of_rval rval =
  match rval with
  | Rexpr expr      -> string_of_expr expr
  | Rstruct rstruct -> string_of_struct_assign rstruct

let string_of_typedef (_, ident) = ident

let rec string_of_fielddecl_list fd_list =
  match fd_list with
  | []        -> ""
  | [fd]      -> string_of_fielddecl fd
  | fd :: fds ->
      String.concat ", " [string_of_fielddecl fd; string_of_fielddecl_list fds]

and
string_of_fielddecl (ident, fieldtype) =
  String.concat " : " [ident; string_of_beantype fieldtype]

and
string_of_beantype bt =
  match bt with
  | TBool                    -> "bool"
  | TInt                     -> "int"
  | TNamedTypedef td_name    -> td_name
  | TAnonTypedef fielddecls ->
      String.concat (string_of_fielddecl_list fielddecls) ["{ "; " }"]

let string_of_typedecl (id, beantype) =
    let bt_string = string_of_beantype beantype in
    String.concat "" [bt_string; " "; id; ";"]

let string_of_pass pass_type =
  match pass_type with
  | Pval  -> "val"
  | Pref  -> "ref"

(* ---- PRINTING HELPER FUNCTIONS ---- *)
let print_indent indent_level =
  for i = 1 to indent_level do
    printf "  "
  done

(* TYPEDEF PRINTING FUNCTIONS *)

let print_typedef_body tdbody =
  match tdbody with
  | TDAlias beantype -> printf "%s" (string_of_beantype beantype)
  | TDStruct fields -> printf "{ %s }" (string_of_fielddecl_list fields)

let print_typedef (tdbody, ident) =
  printf "typedef ";
  print_typedef_body tdbody;
  printf " %s\n" ident

let rec print_typedef_list typedefs =
  match typedefs with
  | []        -> printf "\n"
  | td :: tds -> print_typedef td; print_typedef_list tds

(* ---- DECLARATION PRINTING FUNCTIONS ---- *)
let print_var_decl indent typedecl =
  print_indent indent;
  printf "%s\n" (string_of_typedecl typedecl)

let rec print_decl_list indent dlist =
  match dlist with
  | vdecl :: ds  -> print_var_decl indent vdecl; print_decl_list indent ds
  | []                      -> ()

(* ---- STATEMENT PRINTING FUNCTIONS ---- *)
let print_assign indent lval rval =
  print_indent indent;
  printf "%s := %s;\n" (string_of_lval lval) (string_of_rval rval)

let print_read indent lval =
  print_indent indent;
  printf "read %s;\n" (string_of_lval lval)

let print_write indent writeable =
  print_indent indent;
  match writeable with
  | WExpr expr  -> printf "write %s;\n" (string_of_expr expr)
  | WString str -> let estr = String.escaped str in
                   printf "write %s;\n" (String.concat "" ["\"";estr;"\""])

let print_proc_call indent pname lvals =
  print_indent indent;
  printf "%s(%s);\n" pname (String.concat ", " (List.map string_of_lval lvals))

let rec print_if indent expr ?elses:(slist=[]) stmts =
  print_indent indent;
  printf "if %s then\n" (string_of_expr expr);
  print_stmt_list (indent+1) stmts;
  match slist with
  | [] -> ()
  | _ ->
    print_indent indent;
    printf "else\n";
    print_stmt_list (indent+1) slist;
  print_indent indent;
  printf "fi\n"

and print_while indent expr stmts =
  print_indent indent;
  printf "while %s do\n" (string_of_expr expr);
  print_stmt_list (indent+1) stmts;
  print_indent indent;
  printf "od\n";

(* "and" means print_if, etc. and print_stmt_list are mutually recursive *)
and print_stmt_list indent stmt_list =
  let print_stmt stmt =
    match stmt with
    | Assign (lval, rval)     -> print_assign indent lval rval
    | Read   lval             -> print_read indent lval
    | Write  writeable        -> print_write indent writeable
    | If (expr, stmts)        -> print_if indent expr stmts
    | While (expr, stmts)     -> print_while indent expr stmts
    | ProcCall (ident, lvals) -> print_proc_call indent ident lvals
    | IfElse (expr, if_stmts, else_stmts) ->
        print_if indent expr if_stmts ~elses:else_stmts
  in
  match stmt_list with
  | stmt :: slist   -> print_stmt stmt; print_stmt_list indent slist
  | []              -> ()

let print_proc_head (pass_type, beantype, ident) =
  printf "%s " (string_of_pass pass_type);
  printf "%s " (string_of_beantype beantype);
  printf "%s"  ident

let rec print_proc_head_list head_list =
  match head_list with
  | []         -> ()
  | [head]     -> print_proc_head head
  | head :: hs -> print_proc_head head; printf ", ";
                  print_proc_head_list hs

let print_proc (ident, proc_heads, proc_decls, body_stmts) =
  printf "proc %s(" ident;
  print_proc_head_list proc_heads;
  printf ")\n";
  print_decl_list 1 proc_decls;
  print_stmt_list 1 body_stmts;
  printf "end"

let rec print_proc_list plist =
  match plist with
  | []          -> ();
  | [proc]      -> print_proc proc;
  | proc :: ps  -> print_proc proc; printf "\n\n"; print_proc_list ps;
  printf "\n"

let print_program fmt prog =
  print_typedef_list prog.typedefs;
  print_proc_list prog.procs
