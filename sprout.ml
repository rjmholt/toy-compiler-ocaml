open Format
module P = Sprout_parse
module L = Lexing
module AST = Sprout_ast

(* Argument parsing code *)
let infile_name = ref None

type compiler_mode = PrettyPrint | Compile
let mode = ref Compile

(* --------------------------------------------- *)
(*  Specification for command-line options       *)
(* --------------------------------------------- *)
let (speclist:(Arg.key * Arg.spec * Arg.doc) list) =
  ["-p",
     Arg.Unit(fun () -> mode := PrettyPrint),
     " Run the compiler in pretty-printer mode"
  ]

(* --------------------------------------------- *)
(*  Lexer/Parser error tracking functions        *)
(* --------------------------------------------- *)

let set_lex_file filename lexbuf =
  lexbuf.L.lex_curr_p <- { lexbuf.L.lex_curr_p with
                           pos_fname = filename }

(* Common printing function for errors generated by the
 * semantic analysis component                          *)
let print_semantic_error err_name id pos =
  let (fname, col, ln) = AST.get_lex_pos pos in
  printf "%s -- %s at line %i, column %i in file %s\n"
    err_name id ln col fname

let main () =
  (* Parse the command-line arguments *)
  Arg.parse speclist
      (begin fun fname -> infile_name := Some fname end)
      "bean [-p] [bean source]" ;
  (* Open the input file *)
  let infile = match !infile_name with
  | None -> stdin
  | Some fname -> open_in fname in
  (* Initialize lexing buffer *)
  let lexbuf = Lexing.from_channel infile in
  let filename =
    match !infile_name with
    | None -> "\"stdin\""
    | Some fname -> String.concat "" ["\"";fname;"\""]
  in
  set_lex_file filename lexbuf;
  (* Call the parser *)
  try
    let prog = Sprout_parse.program Sprout_lex.token lexbuf in
    match !mode with
    | PrettyPrint ->
        let symtbl = Bean_symtbl.build_symtbl prog in
        if Bean_semantic.check_semantics symtbl prog
        then
          Sprout_pprint.print_program Format.std_formatter prog 
        else
          printf "Error\n"
    | Compile -> ()
  with
  | Sprout_lex.Syntax_error msg ->
      let (fname, ln, col) = AST.get_lex_pos lexbuf.Lexing.lex_curr_p in
      printf "%s at line %i, column %i in file %s\n"
         msg ln col fname
  | Parsing.Parse_error ->
      let (fname, ln, col) = AST.get_lex_pos lexbuf.Lexing.lex_curr_p in
      printf "%s at line %i, column %i in file %s\n"
        "Parse error" ln col fname
  | Bean_semantic.Undefined_variable (id, pos) ->
      print_semantic_error "Undefined variable" id pos
  | Bean_semantic.Undefined_proc (id, pos) ->
      print_semantic_error "Undefined procedure call" id pos
  | Bean_semantic.Undefined_field (id, pos) ->
      print_semantic_error "Undefined typedef field" id pos
  | Bean_semantic.Type_error (id, pos) ->
      print_semantic_error "Type error" id pos

 let _ = main ()
